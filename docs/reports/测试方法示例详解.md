# 测试方法示例与最佳实践

## 🎯 测试方法分类

### 1. 功能测试 (Functional Testing)

验证系统功能是否按预期工作。

#### 示例：挡板移动功能测试
```typescript
describe('挡板移动功能', () => {
    test('应该能够向左移动指定距离', () => {
        // Arrange (准备)
        const initialPosition = paddleNode.getPosition();
        const moveTime = 0.1;
        const expectedSpeed = 300;
        
        // Act (执行)
        paddleController.moveLeft(moveTime);
        
        // Assert (验证)
        const newPosition = paddleNode.getPosition();
        const actualDistance = initialPosition.x - newPosition.x;
        const expectedDistance = expectedSpeed * moveTime;
        
        expect(actualDistance).toBeCloseTo(expectedDistance, 1);
        expect(newPosition.y).toBe(initialPosition.y); // Y坐标不变
    });
});
```

#### 最佳实践:
- ✅ 使用AAA模式组织测试
- ✅ 测试一个具体功能点
- ✅ 提供清晰的测试描述
- ✅ 验证所有相关状态变化

### 2. 边界测试 (Boundary Testing)

测试系统在边界条件下的行为。

#### 示例：挡板边界限制测试
```typescript
describe('挡板边界限制', () => {
    test('不应该移动超出左边界', () => {
        // Arrange
        const screenWidth = 960;
        const paddleWidth = 100;
        const boundaryMargin = 50;
        const leftBoundary = -(screenWidth / 2) + (paddleWidth / 2) + boundaryMargin;
        
        // 将挡板移动到边界外
        paddleNode.setPosition(leftBoundary - 100, -250, 0);
        
        // Act
        paddleController.moveLeft(1.0); // 长时间移动
        
        // Assert
        const finalPosition = paddleNode.getPosition();
        expect(finalPosition.x).toBeGreaterThanOrEqual(leftBoundary);
    });
    
    test('应该正确处理极端输入值', () => {
        const initialPosition = paddleNode.getPosition().clone();
        
        // 测试负数时间
        paddleController.moveLeft(-0.1);
        expect(paddleNode.getPosition().equals(initialPosition)).toBe(true);
        
        // 测试零时间
        paddleController.moveLeft(0);
        expect(paddleNode.getPosition().equals(initialPosition)).toBe(true);
        
        // 测试NaN
        paddleController.moveLeft(NaN);
        expect(paddleNode.getPosition().equals(initialPosition)).toBe(true);
        
        // 测试Infinity
        paddleController.moveLeft(Infinity);
        expect(paddleNode.getPosition().x).toBeFinite();
    });
});
```

### 3. 状态测试 (State Testing)

验证对象状态转换的正确性。

#### 示例：弹球状态管理测试
```typescript
describe('弹球状态管理', () => {
    test('应该正确管理运动状态', () => {
        // 初始状态：未移动
        expect(ball.isMoving).toBe(false);
        
        // 发射后：正在移动
        ball.launch(new Vec3(1, 1, 0).normalize());
        expect(ball.isMoving).toBe(true);
        
        // 重置后：停止移动
        ball.resetBall();
        expect(ball.isMoving).toBe(false);
    });
    
    test('应该正确管理特效状态', () => {
        // 应用火焰特效
        ball.applyFireEffect(5.0);
        expect(ball.hasFireEffect()).toBe(true);
        expect(ball.getFireEffectDuration()).toBe(5.0);
        
        // 时间流逝
        ball.update(2.0);
        expect(ball.getFireEffectDuration()).toBe(3.0);
        
        // 特效结束
        ball.update(3.1);
        expect(ball.hasFireEffect()).toBe(false);
    });
});
```

### 4. 交互测试 (Interaction Testing)

测试组件间的交互行为。

#### 示例：碰撞检测交互测试
```typescript
describe('碰撞检测交互', () => {
    test('弹球与挡板碰撞应该改变弹球方向', () => {
        // Arrange
        ball.start();
        const mockPaddle = new Node('MockPaddle');
        mockPaddle.addComponent('PaddleController');
        mockPaddle.setPosition(0, -200, 0);
        
        ballNode.setPosition(50, -180, 0); // 球在挡板右侧
        const originalVelocity = new Vec3(100, -200, 0);
        ball.setVelocity(originalVelocity);
        
        // Act
        const mockContact = {
            otherCollider: { node: mockPaddle }
        };
        ball.onBeginContact(null, mockContact, null);
        
        // Assert
        const newVelocity = ball.getVelocity();
        expect(newVelocity.y).toBeGreaterThan(0); // 向上反弹
        expect(newVelocity.x).toBeGreaterThan(originalVelocity.x); // 角度偏转
    });
    
    test('遗物效果应该正确影响弹球行为', () => {
        // Arrange
        const relicManager = RelicManager.getInstance();
        relicManager.grantRelic(RelicType.FIRE_BALLS);
        
        const mockBall = new Node('MockBall');
        
        // Act
        relicManager.onBallLaunched(mockBall);
        
        // Assert
        const fireEffectApplied = mockBall.getComponent('Ball')?.hasFireEffect();
        expect(fireEffectApplied).toBe(true);
    });
});
```

### 5. 性能测试 (Performance Testing)

验证系统在负载下的性能表现。

#### 示例：批量操作性能测试
```typescript
describe('性能测试', () => {
    test('批量更新应该在合理时间内完成', () => {
        const startTime = performance.now();
        const iterations = 1000;
        
        // 执行大量更新操作
        for (let i = 0; i < iterations; i++) {
            paddleController.update(0.016); // 模拟60FPS
        }
        
        const endTime = performance.now();
        const duration = endTime - startTime;
        const avgTimePerUpdate = duration / iterations;
        
        expect(duration).toBeLessThan(100); // 总时间不超过100ms
        expect(avgTimePerUpdate).toBeLessThan(0.1); // 每次更新不超过0.1ms
    });
    
    test('内存使用应该保持稳定', () => {
        const initialMemory = process.memoryUsage().heapUsed;
        
        // 执行可能造成内存泄漏的操作
        for (let i = 0; i < 100; i++) {
            const tempBall = new Node(`TempBall${i}`);
            tempBall.addComponent('Ball');
            // 模拟创建和销毁
            tempBall.destroy();
        }
        
        // 强制垃圾回收 (仅在测试环境)
        if (global.gc) global.gc();
        
        const finalMemory = process.memoryUsage().heapUsed;
        const memoryIncrease = finalMemory - initialMemory;
        
        expect(memoryIncrease).toBeLessThan(1024 * 1024); // 增长不超过1MB
    });
});
```

### 6. 错误处理测试 (Error Handling Testing)

验证系统对异常情况的处理能力。

#### 示例：异常输入处理测试
```typescript
describe('错误处理', () => {
    test('应该优雅处理空指针异常', () => {
        expect(() => {
            ball.onBeginContact(null, null, null);
        }).not.toThrow();
        
        expect(() => {
            ball.onBeginContact(null, { otherCollider: null }, null);
        }).not.toThrow();
        
        expect(() => {
            ball.onBeginContact(null, { otherCollider: { node: null } }, null);
        }).not.toThrow();
    });
    
    test('应该处理无效的保存数据', () => {
        const saveManager = SaveManager.getInstance();
        
        // 测试各种无效输入
        const invalidInputs = [
            null,
            undefined,
            {},
            { invalidField: 'value' },
            { playerProgress: null },
            { playerProgress: { totalScore: 'invalid' } }
        ];
        
        invalidInputs.forEach(input => {
            expect(() => {
                saveManager.loadFromSaveData(input);
            }).not.toThrow();
        });
        
        // 验证加载失败后系统仍可用
        expect(saveManager.getPlayerProgress()).toBeDefined();
    });
});
```

### 7. 集成测试 (Integration Testing)

测试多个组件协同工作的场景。

#### 示例：完整游戏流程测试
```typescript
describe('游戏流程集成测试', () => {
    test('完整的砖块破坏流程', () => {
        // Arrange - 设置完整的游戏场景
        const gameManager = GameManager.getInstance();
        const relicManager = RelicManager.getInstance();
        const effectSystem = AdvancedEffectSystem.getInstance();
        
        gameManager.initializeGame();
        relicManager.grantRelic(RelicType.EXPLOSIVE_BRICKS);
        
        // Act - 模拟弹球击中砖块
        const mockBrick = new Node('TestBrick');
        mockBrick.setPosition(100, 100, 0);
        mockBrick.addComponent('Brick');
        
        const initialScore = gameManager.getScore();
        
        // 触发砖块被破坏事件
        gameManager.onBrickDestroyed(10, mockBrick.getPosition(), true);
        relicManager.onBrickDestroyed(mockBrick);
        
        // Assert - 验证所有相关系统响应
        expect(gameManager.getScore()).toBe(initialScore + 10);
        expect(mockBrick.isValid).toBe(false); // 砖块被销毁
        
        // 验证爆炸效果被触发
        const activeEffects = effectSystem.getActiveEffects();
        expect(activeEffects.some(effect => 
            effect.type === 'brick_explosion'
        )).toBe(true);
    });
});
```

## 🛠️ Mock 策略详解

### 1. 组件 Mock
```typescript
// 创建轻量级的组件Mock
function createMockNode(name: string = 'MockNode') {
    return {
        name,
        _position: new Vec3(0, 0, 0),
        _components: new Map(),
        
        getPosition(): Vec3 { return this._position.clone(); },
        setPosition(pos: Vec3): void { this._position = pos.clone(); },
        
        addComponent<T>(type: string): T {
            const component = createMockComponent(type);
            this._components.set(type, component);
            return component as T;
        },
        
        getComponent<T>(type: string): T | null {
            return this._components.get(type) as T || null;
        },
        
        destroy(): void { this._destroyed = true; },
        get isValid(): boolean { return !this._destroyed; }
    };
}
```

### 2. 物理系统 Mock
```typescript
function createMockRigidBody() {
    return {
        linearVelocity: new Vec3(0, 0, 0),
        body: {
            SetLinearVelocity: jest.fn(),
            GetLinearVelocity: jest.fn().mockReturnValue({ x: 0, y: 0 }),
            SetTransform: jest.fn(),
            GetTransform: jest.fn()
        },
        
        // 模拟物理更新
        simulatePhysicsStep(deltaTime: number): void {
            // 简单的位置更新模拟
            this.linearVelocity.multiplyScalar(0.99); // 模拟阻尼
        }
    };
}
```

### 3. 事件系统 Mock
```typescript
function createMockEventSystem() {
    const listeners = new Map<string, Function[]>();
    
    return {
        on(event: string, callback: Function): void {
            if (!listeners.has(event)) {
                listeners.set(event, []);
            }
            listeners.get(event)!.push(callback);
        },
        
        emit(event: string, ...args: any[]): void {
            const callbacks = listeners.get(event) || [];
            callbacks.forEach(callback => callback(...args));
        },
        
        off(event: string, callback: Function): void {
            const callbacks = listeners.get(event) || [];
            const index = callbacks.indexOf(callback);
            if (index !== -1) {
                callbacks.splice(index, 1);
            }
        }
    };
}
```

## 📊 测试数据生成

### 1. 随机测试数据
```typescript
class TestDataGenerator {
    static randomPosition(bounds?: {min: Vec3, max: Vec3}): Vec3 {
        const min = bounds?.min || new Vec3(-500, -300, 0);
        const max = bounds?.max || new Vec3(500, 300, 0);
        
        return new Vec3(
            Math.random() * (max.x - min.x) + min.x,
            Math.random() * (max.y - min.y) + min.y,
            0
        );
    }
    
    static randomVelocity(maxSpeed: number = 500): Vec3 {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * maxSpeed;
        
        return new Vec3(
            Math.cos(angle) * speed,
            Math.sin(angle) * speed,
            0
        );
    }
    
    static randomPlayerProgress(): PlayerProgress {
        return {
            currentChapter: Math.floor(Math.random() * 3) + 1,
            currentFloor: Math.floor(Math.random() * 15) + 1,
            totalScore: Math.floor(Math.random() * 100000),
            // ... 其他随机字段
        };
    }
}

// 使用示例
test('应该处理随机玩家数据', () => {
    const randomProgress = TestDataGenerator.randomPlayerProgress();
    const saveManager = SaveManager.getInstance();
    
    expect(() => {
        saveManager.setPlayerProgress(randomProgress);
    }).not.toThrow();
});
```

### 2. 边界值测试数据
```typescript
class BoundaryTestData {
    static getPositionBoundaries() {
        return [
            new Vec3(0, 0, 0),                    // 原点
            new Vec3(-480, -320, 0),              // 左下角
            new Vec3(480, 320, 0),                // 右上角
            new Vec3(Number.MAX_VALUE, 0, 0),     // 极大值
            new Vec3(-Number.MAX_VALUE, 0, 0),    // 极小值
            new Vec3(NaN, NaN, 0),                // NaN值
            new Vec3(Infinity, -Infinity, 0)      // 无穷值
        ];
    }
    
    static getScoreBoundaries() {
        return [
            0, 1, -1,
            Number.MAX_SAFE_INTEGER,
            Number.MIN_SAFE_INTEGER,
            Number.MAX_VALUE,
            -Number.MAX_VALUE,
            NaN, Infinity, -Infinity
        ];
    }
}
```

## 🎯 断言最佳实践

### 1. 精确断言
```typescript
// ❌ 模糊断言
expect(result).toBeTruthy();

// ✅ 精确断言
expect(result.success).toBe(true);
expect(result.data).toBeDefined();
expect(result.errorCode).toBe(0);
```

### 2. 浮点数比较
```typescript
// ❌ 直接比较浮点数
expect(actualDistance).toBe(expectedDistance);

// ✅ 使用精度容错
expect(actualDistance).toBeCloseTo(expectedDistance, 2);
```

### 3. 异步断言
```typescript
// ❌ 不等待异步操作
test('异步加载', () => {
    saveManager.loadAsync();
    expect(saveManager.isLoaded()).toBe(true);
});

// ✅ 正确处理异步
test('异步加载', async () => {
    await saveManager.loadAsync();
    expect(saveManager.isLoaded()).toBe(true);
});
```

## 🔧 调试技巧

### 1. 测试隔离
```typescript
describe('隔离测试', () => {
    let originalConsoleError: typeof console.error;
    
    beforeAll(() => {
        // 静默错误日志
        originalConsoleError = console.error;
        console.error = jest.fn();
    });
    
    afterAll(() => {
        // 恢复原始日志
        console.error = originalConsoleError;
    });
    
    beforeEach(() => {
        // 每个测试前重置Mock
        jest.clearAllMocks();
    });
});
```

### 2. 调试信息输出
```typescript
test('复杂逻辑调试', () => {
    const debugInfo = {
        initialState: paddle.getState(),
        inputEvent: mockEvent,
        expectedResult: expectedState
    };
    
    try {
        paddle.handleInput(mockEvent);
        const actualResult = paddle.getState();
        
        expect(actualResult).toEqual(expectedResult);
    } catch (error) {
        console.log('调试信息:', debugInfo);
        console.log('实际结果:', paddle.getState());
        throw error;
    }
});
```

### 3. 条件测试
```typescript
// 根据环境条件跳过测试
const skipOnCI = process.env.CI ? test.skip : test;

skipOnCI('本地环境性能测试', () => {
    // 只在本地运行的性能测试
});
```

---

**🎮 通过这些测试方法和最佳实践，我们确保 Cat-Conquest 游戏系统的高质量和稳定性！**