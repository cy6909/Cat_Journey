# DynamicLevelGenerator.ts 使用说明

## 功能概述
DynamicLevelGenerator是一个综合性的关卡生成系统，能够根据地图选择、难度约束和特殊条件动态生成多样化的砖块布局。

## 核心功能

### 1. 多样化布局模式
- **STANDARD**: 标准矩形布局，适合普通关卡
- **PYRAMID**: 金字塔布局，上层难度递增
- **DIAMOND**: 钻石布局，中心区域最难
- **SPIRAL**: 螺旋布局，创造独特的游戏路径
- **FORTRESS**: 要塞布局，外墙防护内部结构
- **CHAOS**: 混沌布局，随机分布增加不可预测性
- **TUNNEL**: 隧道布局，创造狭窄通道挑战
- **WAVES**: 波浪布局，正弦波形状的视觉效果

### 2. 智能难度调节
根据多个因素计算难度倍数：
- 章节进度（每章+0.5倍数）
- 层数进度（每层+0.1倍数）
- 难度级别（简单0.8x，普通1.0x，困难1.3x，噩梦1.8x）
- 节点类型（精英1.4x，Boss 2.0x，最终Boss 3.0x）

### 3. 特殊修饰符系统
- **electric_storm**: 20%砖块转换为电击砖块，附加连锁闪电效果
- **fire_zone**: 中心区域砖块转换为火焰砖块，附加燃烧光环
- **ice_field**: 1/3砖块转换为冰霜砖块，附加减速光环
- **explosive_cluster**: 15%砖块转换为爆炸砖块，附加集群炸弹效果
- **regeneration_field**: 10%砖块获得再生能力，附加区域再生效果

## 主要方法

### generateLevelLayout(params: LevelGenerationParams): BrickLayoutData[]
根据输入参数生成完整的关卡布局数据。

**参数说明:**
- `chapterNumber`: 当前章节编号(1-3)
- `floorNumber`: 当前层数编号(1-15)
- `levelType`: 关卡类型(NORMAL/ELITE/BOSS)
- `difficultyTier`: 难度级别(EASY/NORMAL/HARD/NIGHTMARE)
- `nodeType`: 地图节点类型(COMBAT/ELITE/BOSS等12种)
- `layoutPattern`: 布局模式(8种预定义模式)
- `specialModifiers`: 特殊修饰符数组

**返回值:**
BrickLayoutData[]数组，包含每个砖块的位置、类型、血量、特效和难度倍数。

### getRecommendedLayoutPattern(params): LevelLayoutPattern
根据关卡参数推荐最适合的布局模式。

### getRecommendedModifiers(params): string[]
根据关卡参数推荐适合的特殊修饰符。

## 在Cocos Creator中的绑定使用

### 1. 创建组件
1. 在GameScene中创建一个空的Node，命名为"LevelGenerator"
2. 将DynamicLevelGenerator脚本拖拽到该Node上
3. 在Inspector中配置基础参数：
   - gridWidth: 砖块网格宽度(默认8)
   - gridHeight: 砖块网格高度(默认6)
   - brickWidth/Height: 砖块尺寸(默认80x40)
   - brickSpacing: 砖块间距(默认10)
   - startX/startY: 起始位置(默认-280, 200)

### 2. 与GameManager集成
在GameManager.ts中调用生成器：

```typescript
private setupLevel(): void {
    const generator = DynamicLevelGenerator.getInstance();
    if (generator && this._mapManager && this._levelManager) {
        const params: LevelGenerationParams = {
            chapterNumber: this._mapManager.getCurrentChapter(),
            floorNumber: this._mapManager.getCurrentFloor(),
            levelType: this._levelManager.getCurrentLevelType(),
            difficultyTier: this._levelManager.getCurrentDifficulty(),
            nodeType: this._mapManager.getCurrentNodeType(),
            layoutPattern: generator.getRecommendedLayoutPattern(params),
            specialModifiers: generator.getRecommendedModifiers(params)
        };
        
        const layoutData = generator.generateLevelLayout(params);
        this.createBricksFromLayoutData(layoutData);
    }
}

private createBricksFromLayoutData(layoutData: BrickLayoutData[]): void {
    layoutData.forEach(brickData => {
        if (!this.brickPrefab || !this.brickContainer) return;
        
        const brick = instantiate(this.brickPrefab);
        brick.setPosition(brickData.position);
        
        const brickScript = brick.getComponent('EnhancedBrick');
        if (brickScript) {
            (brickScript as any).initializeBrick(
                brickData.brickType,
                brickData.health,
                brickData.specialEffects
            );
        }
        
        this.brickContainer.addChild(brick);
        this._bricks.push(brick);
    });
}
```

### 3. 与MapManager协作
确保MapManager提供当前节点信息：

```typescript
// 在MapManager中
public getCurrentNodeType(): MapNodeType {
    return this.currentNodeType;
}

public getCurrentChapter(): number {
    return Math.floor(this.currentFloor / 15) + 1;
}

public getCurrentFloor(): number {
    return this.currentFloor;
}
```

## 扩展指南

### 添加新的布局模式
1. 在LevelLayoutPattern枚举中添加新类型
2. 在generateLevelLayout的switch语句中添加对应case
3. 实现对应的生成方法(参考现有的generate*Layout方法)

### 添加新的特殊修饰符
1. 在applySpecialModifiers方法中添加新的修饰符处理
2. 实现对应的apply*方法
3. 在getRecommendedModifiers中添加推荐逻辑

### 自定义砖块选择逻辑
修改selectBrickType方法，根据位置、难度、特殊条件选择不同的砖块类型。

## 性能优化建议
1. 生成的布局数据可以缓存，避免重复计算
2. 使用对象池管理砖块实例
3. 根据设备性能动态调整网格大小和效果密度

## 调试功能
组件会在控制台输出关卡生成信息，包括：
- 生成参数
- 砖块总数
- 应用的修饰符效果

## 与其他系统的依赖关系
- 依赖LevelManager获取难度和类型信息
- 依赖MapManager获取节点和章节信息
- 需要EnhancedBrick组件支持高级砖块类型
- 与RelicManager协作应用遗物效果