{"version":3,"sources":["file:///D:/project/claudecode/wx/Cat_Journey/assets/scripts/managers/ExperienceOrb.ts"],"names":["_decorator","Component","RigidBody2D","Vec3","Vec2","Collider2D","Contact2DType","GameManager","ExperienceManager","ccclass","property","ExperienceOrb","_rigidBody","_paddleNode","_coreNode","_isBeingAttracted","onLoad","getComponent","collider","on","BEGIN_CONTACT","onBeginContact","scheduleOnce","node","isValid","destroy","lifeTime","start","findTargets","setInitialVelocity","update","dt","updateMagnetism","gameManager","getInstance","getPaddleNode","getCoreController","randomX","Math","random","linearVelocity","fallSpeed","currentPos","position","closestTarget","closestDistance","Infinity","paddleDistance","distance","magnetRange","coreDistance","attractToTarget","target","targetPos","direction","subtract","normalize","attractionForce","attractionVelocity","multiplyScalar","x","y","selfCollider","otherCollider","contact","otherNode","name","includes","onCollected","expManager","addExperience","experienceValue","showCollectionEffect","sprite","color","r","g","b","a","getExperienceValue","setExperienceValue","value"],"mappings":"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","sourcesContent":["import { _decorator, Component, Node, RigidBody2D, Vec3, Vec2, Collider2D, Contact2DType, IPhysics2DContact, find } from 'cc';\r\nimport { GameManager } from '../gameplay/GameManager';\r\nimport { ExperienceManager } from './ExperienceManager';\r\n\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('ExperienceOrb')\r\nexport class ExperienceOrb extends Component {\r\n    @property\r\n    public fallSpeed: number = 200.0;\r\n    \r\n    @property\r\n    public experienceValue: number = 10;\r\n    \r\n    @property\r\n    public lifeTime: number = 8.0; // Auto-destroy after 8 seconds\r\n    \r\n    @property\r\n    public magnetRange: number = 150.0; // Range at which orb is attracted to paddle/core\r\n    \r\n    private _rigidBody: RigidBody2D | null = null;\r\n    private _paddleNode: Node | null = null;\r\n    private _coreNode: Node | null = null;\r\n    private _isBeingAttracted: boolean = false;\r\n    \r\n    protected onLoad(): void {\r\n        this._rigidBody = this.getComponent(RigidBody2D);\r\n        \r\n        const collider = this.getComponent(Collider2D);\r\n        if (collider) {\r\n            collider.on(Contact2DType.BEGIN_CONTACT, this.onBeginContact, this);\r\n        }\r\n        \r\n        // Auto-destroy after lifetime expires\r\n        this.scheduleOnce(() => {\r\n            if (this.node && this.node.isValid) {\r\n                this.node.destroy();\r\n            }\r\n        }, this.lifeTime);\r\n    }\r\n    \r\n    protected start(): void {\r\n        this.findTargets();\r\n        this.setInitialVelocity();\r\n    }\r\n    \r\n    protected update(dt: number): void {\r\n        this.updateMagnetism(dt);\r\n    }\r\n    \r\n    private findTargets(): void {\r\n        // Find paddle and core nodes for magnetism\r\n        const gameManager = GameManager.getInstance();\r\n        if (gameManager) {\r\n            this._paddleNode = gameManager.getPaddleNode();\r\n            this._coreNode = gameManager.getCoreController()?.node || null;\r\n        }\r\n    }\r\n    \r\n    private setInitialVelocity(): void {\r\n        if (this._rigidBody) {\r\n            // Start falling down with slight random horizontal movement\r\n            const randomX = (Math.random() - 0.5) * 50;\r\n            this._rigidBody.linearVelocity = new Vec2(randomX, -this.fallSpeed);\r\n        }\r\n    }\r\n    \r\n    private updateMagnetism(dt: number): void {\r\n        if (this._isBeingAttracted) return;\r\n        \r\n        const currentPos = this.node.position;\r\n        let closestTarget: Node | null = null;\r\n        let closestDistance = Infinity;\r\n        \r\n        // Check distance to paddle\r\n        if (this._paddleNode && this._paddleNode.isValid) {\r\n            const paddleDistance = Vec3.distance(currentPos, this._paddleNode.position);\r\n            if (paddleDistance < this.magnetRange && paddleDistance < closestDistance) {\r\n                closestTarget = this._paddleNode;\r\n                closestDistance = paddleDistance;\r\n            }\r\n        }\r\n        \r\n        // Check distance to core\r\n        if (this._coreNode && this._coreNode.isValid) {\r\n            const coreDistance = Vec3.distance(currentPos, this._coreNode.position);\r\n            if (coreDistance < this.magnetRange && coreDistance < closestDistance) {\r\n                closestTarget = this._coreNode;\r\n                closestDistance = coreDistance;\r\n            }\r\n        }\r\n        \r\n        // Apply magnetism if target found\r\n        if (closestTarget && this._rigidBody) {\r\n            this._isBeingAttracted = true;\r\n            this.attractToTarget(closestTarget);\r\n        }\r\n    }\r\n    \r\n    private attractToTarget(target: Node): void {\r\n        if (!this._rigidBody) return;\r\n        \r\n        const currentPos = this.node.position;\r\n        const targetPos = target.position;\r\n        \r\n        // Calculate direction to target\r\n        const direction = new Vec3();\r\n        Vec3.subtract(direction, targetPos, currentPos);\r\n        direction.normalize();\r\n        \r\n        // Apply attraction force\r\n        const attractionForce = 500; // Strong attraction\r\n        const attractionVelocity = Vec3.multiplyScalar(new Vec3(), direction, attractionForce);\r\n        this._rigidBody.linearVelocity = new Vec2(attractionVelocity.x, attractionVelocity.y);\r\n    }\r\n    \r\n    private onBeginContact(selfCollider: Collider2D, otherCollider: Collider2D, contact: IPhysics2DContact | null): void {\r\n        const otherNode = otherCollider.node;\r\n        \r\n        // Check if collected by paddle or core\r\n        if (otherNode.name.includes('Paddle') || otherNode.name.includes('Core')) {\r\n            this.onCollected();\r\n        }\r\n    }\r\n    \r\n    private onCollected(): void {\r\n        // Add experience to ExperienceManager\r\n        const expManager = ExperienceManager.getInstance();\r\n        if (expManager) {\r\n            expManager.addExperience(this.experienceValue);\r\n        }\r\n\r\n        this.showCollectionEffect();\r\n\r\n        // Destroy the orb\r\n        this.node.destroy();\r\n    }\r\n    \r\n    private showCollectionEffect(): void {\r\n        // Visual feedback for collection\r\n        const sprite = this.getComponent('cc.Sprite');\r\n        if (sprite) {\r\n            // Quick flash before destruction\r\n            (sprite as any).color = { r: 255, g: 255, b: 255, a: 255 };\r\n        }\r\n\r\n        // Could add particle effect or sound here\r\n    }\r\n    \r\n    public getExperienceValue(): number {\r\n        return this.experienceValue;\r\n    }\r\n    \r\n    public setExperienceValue(value: number): void {\r\n        this.experienceValue = value;\r\n    }\r\n}"]}