{"version":3,"sources":["file:///E:/work_space/wx/Cat_Journey/assets/scripts/ExperienceOrb.ts"],"names":["_decorator","Component","RigidBody2D","Vec3","Collider2D","Contact2DType","ccclass","property","ExperienceOrb","_rigidBody","_paddleNode","_coreNode","_isBeingAttracted","onLoad","getComponent","collider","on","BEGIN_CONTACT","onBeginContact","scheduleOnce","node","isValid","destroy","lifeTime","start","findTargets","setInitialVelocity","update","dt","updateMagnetism","gameManager","require","GameManager","getInstance","coreNode","randomX","Math","random","linearVelocity","fallSpeed","currentPos","position","closestTarget","closestDistance","Infinity","paddleDistance","distance","magnetRange","coreDistance","attractToTarget","target","targetPos","direction","subtract","normalize","attractionForce","attractionVelocity","multiplyScalar","selfCollider","otherCollider","contact","otherNode","name","includes","onCollected","console","log","experienceValue","coreController","addExperience","showCollectionEffect","sprite","color","r","g","b","a","getExperienceValue","setExperienceValue","value"],"mappings":"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","sourcesContent":["import { _decorator, Component, Node, RigidBody2D, Vec3, Collider2D, Contact2DType, IPhysics2DContact } from 'cc';\n\nconst { ccclass, property } = _decorator;\n\n@ccclass('ExperienceOrb')\nexport class ExperienceOrb extends Component {\n    @property\n    public fallSpeed: number = 200.0;\n    \n    @property\n    public experienceValue: number = 10;\n    \n    @property\n    public lifeTime: number = 8.0; // Auto-destroy after 8 seconds\n    \n    @property\n    public magnetRange: number = 150.0; // Range at which orb is attracted to paddle/core\n    \n    private _rigidBody: RigidBody2D | null = null;\n    private _paddleNode: Node | null = null;\n    private _coreNode: Node | null = null;\n    private _isBeingAttracted: boolean = false;\n    \n    protected onLoad(): void {\n        this._rigidBody = this.getComponent(RigidBody2D);\n        \n        const collider = this.getComponent(Collider2D);\n        if (collider) {\n            collider.on(Contact2DType.BEGIN_CONTACT, this.onBeginContact, this);\n        }\n        \n        // Auto-destroy after lifetime expires\n        this.scheduleOnce(() => {\n            if (this.node && this.node.isValid) {\n                this.node.destroy();\n            }\n        }, this.lifeTime);\n    }\n    \n    protected start(): void {\n        this.findTargets();\n        this.setInitialVelocity();\n    }\n    \n    protected update(dt: number): void {\n        this.updateMagnetism(dt);\n    }\n    \n    private findTargets(): void {\n        // Find paddle and core nodes for magnetism\n        const gameManager = require('./GameManager').GameManager.getInstance();\n        if (gameManager) {\n            this._paddleNode = (gameManager as any)._paddleNode;\n            this._coreNode = (gameManager as any).coreNode;\n        }\n    }\n    \n    private setInitialVelocity(): void {\n        if (this._rigidBody) {\n            // Start falling down with slight random horizontal movement\n            const randomX = (Math.random() - 0.5) * 50;\n            this._rigidBody.linearVelocity = new Vec3(randomX, -this.fallSpeed, 0);\n        }\n    }\n    \n    private updateMagnetism(dt: number): void {\n        if (this._isBeingAttracted) return;\n        \n        const currentPos = this.node.position;\n        let closestTarget: Node | null = null;\n        let closestDistance = Infinity;\n        \n        // Check distance to paddle\n        if (this._paddleNode && this._paddleNode.isValid) {\n            const paddleDistance = Vec3.distance(currentPos, this._paddleNode.position);\n            if (paddleDistance < this.magnetRange && paddleDistance < closestDistance) {\n                closestTarget = this._paddleNode;\n                closestDistance = paddleDistance;\n            }\n        }\n        \n        // Check distance to core\n        if (this._coreNode && this._coreNode.isValid) {\n            const coreDistance = Vec3.distance(currentPos, this._coreNode.position);\n            if (coreDistance < this.magnetRange && coreDistance < closestDistance) {\n                closestTarget = this._coreNode;\n                closestDistance = coreDistance;\n            }\n        }\n        \n        // Apply magnetism if target found\n        if (closestTarget && this._rigidBody) {\n            this._isBeingAttracted = true;\n            this.attractToTarget(closestTarget);\n        }\n    }\n    \n    private attractToTarget(target: Node): void {\n        if (!this._rigidBody) return;\n        \n        const currentPos = this.node.position;\n        const targetPos = target.position;\n        \n        // Calculate direction to target\n        const direction = new Vec3();\n        Vec3.subtract(direction, targetPos, currentPos);\n        direction.normalize();\n        \n        // Apply attraction force\n        const attractionForce = 500; // Strong attraction\n        const attractionVelocity = direction.multiplyScalar(attractionForce);\n        this._rigidBody.linearVelocity = attractionVelocity;\n    }\n    \n    private onBeginContact(selfCollider: Collider2D, otherCollider: Collider2D, contact: IPhysics2DContact | null): void {\n        const otherNode = otherCollider.node;\n        \n        // Check if collected by paddle or core\n        if (otherNode.name.includes('Paddle') || otherNode.name.includes('Core')) {\n            this.onCollected();\n        }\n    }\n    \n    private onCollected(): void {\n        console.log(`Experience orb collected! Value: ${this.experienceValue}`);\n        \n        // Find core controller and add experience\n        if (this._coreNode) {\n            const coreController = this._coreNode.getComponent('CoreController');\n            if (coreController) {\n                (coreController as any).addExperience(this.experienceValue);\n            }\n        }\n        \n        this.showCollectionEffect();\n        \n        // Destroy the orb\n        this.node.destroy();\n    }\n    \n    private showCollectionEffect(): void {\n        // Visual feedback for collection\n        const sprite = this.getComponent('cc.Sprite');\n        if (sprite) {\n            // Quick flash before destruction\n            (sprite as any).color = { r: 255, g: 255, b: 255, a: 255 };\n        }\n        \n        // Could add particle effect or sound here\n        console.log('Experience orb collection effect played');\n    }\n    \n    public getExperienceValue(): number {\n        return this.experienceValue;\n    }\n    \n    public setExperienceValue(value: number): void {\n        this.experienceValue = value;\n    }\n}"]}