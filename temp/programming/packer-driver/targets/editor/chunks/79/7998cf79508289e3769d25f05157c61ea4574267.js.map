{"version":3,"sources":["file:///E:/work_space/wx/Cat_Journey/assets/scripts/MapManager.ts"],"names":["_decorator","Component","Vec3","Prefab","instantiate","Color","Sprite","Label","Button","UITransform","EliteType","BossType","ccclass","property","NodeType","ChapterTheme","MapManager","type","_currentChapter","_currentFloor","_currentNodeId","_mapNodes","Map","_completedNodes","_chapterTheme","FOREST","_nodeTypeDistribution","_chapterBossTypes","_availableEliteTypes","_nodeVisuals","_connectionLines","onLoad","initializeNodeDistribution","initializeChapterBosses","loadMapProgress","start","generateChapterMap","set","COMBAT","ELITE","EVENT","SHOP","TREASURE","CAMPFIRE","UPGRADE","MYSTERY","GUARDIAN_WALL","STORM_CALLER","BRICK_SPAWNER","GRAVITY_MASTER","TIME_MANIPULATOR","SHIELD_GENERATOR","MULTI_PHASE","TELEPORTER","ELEMENTAL_CHAOS","MIRROR_BOSS","BRICK_FORTRESS","SPEED_DEMON","REGENERATOR","GRAVITY_ANOMALY","TIME_DISTORTION","PHASE_SHIFTER","MAGNETIC_STORM","SHIELD_MATRIX","VOID_CORRUPTION","chapter","getChapterTheme","console","log","clearCurrentMap","generateMapNodes","generateConnections","calculateAvailableNodes","createMapVisuals","startNodes","getNodesByType","START","length","id","updateNodeAvailability","clear","floor","floorsPerChapter","generateFloorNodes","size","nodeCount","getNodeCountForFloor","createNode","bossTypes","get","randomBoss","Math","random","bossNode","BOSS","bossData","bossType","i","createCombatNode","generateRegularFloor","nodesToCreate","nodeType","selectRandomNodeType","push","includes","nodeId","createNodeByType","position","node","setupCombatNode","setupEliteNode","setupEventNode","setupShopNode","setupTreasureNode","setupMysteryNode","nodeSpacing","floorSpacing","connections","isVisited","isAvailable","isCurrentPath","baseDifficulty","combatData","difficulty","brickCount","specialBrickRatio","min","randomElite","eliteData","eliteType","events","getAvailableEvents","randomEvent","eventData","eventType","choices","shopData","items","generateShopItems","currency","treasureTypes","randomType","treasureData","rewardType","rewardValue","generateTreasureReward","nodesByFloor","groupNodesByFloor","currentFloorNodes","nextFloorNodes","connectFloors","currentFloor","nextFloor","floorIndex","currentNode","connectionCount","targetIndices","selectConnectionTargets","indexOf","targetIndex","targetNode","ensureNodesReachable","sourceIndex","targetCount","targets","sourcePosition","max","round","range","centerIndex","minIndex","maxIndex","reachableNodes","Set","connectionId","add","nextNode","has","randomCurrentNode","clearMapVisuals","createNodeVisual","createConnectionVisuals","mapNodePrefab","nodeVisual","sprite","getComponent","label","getComponentInChildren","button","color","getNodeColor","string","getNodeDisplayName","on","EventType","CLICK","onNodeClicked","setParent","setPosition","updateNodeVisualState","connectionLinePrefab","line","startPos","endPos","midPos","lerp","distance","transform","width","angle","atan2","y","x","setRotationFromEuler","PI","executeNodeAction","updateAllNodeVisuals","startCombat","startEliteCombat","startBossCombat","triggerEvent","enterShop","openTreasure","restAtCampfire","enterUpgradeStation","encounterMystery","totalWeight","Array","from","values","reduce","sum","weight","entries","nodesPerFloor","MOUNTAIN","ABYSS","floorGroups","filter","connectedNode","visual","WHITE","destroy","theme","text","consequences","value","description","name","cost","data","healing","damageBonus","relicType","tier","amount","quantity","saveMapProgress","getCurrentNode","getCurrentChapter","getCurrentFloor","isChapterComplete","getNextChapterAvailable","updateAvailableNodes","completedNode","getNodeById"],"mappings":"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","sourcesContent":["import { _decorator, Component, Node, Vec3, Prefab, instantiate, Color, Sprite, Label, Button, UITransform } from 'cc';\r\nimport { EliteType, HiddenBossType } from './EliteAndHiddenBossManager';\r\nimport { BossType } from './EnhancedBossController';\r\n\r\nconst { ccclass, property } = _decorator;\r\n\r\nexport enum NodeType {\r\n    COMBAT = 'combat',           // 普通战斗\r\n    ELITE = 'elite',            // 精英战斗\r\n    BOSS = 'boss',              // Boss战斗\r\n    HIDDEN_BOSS = 'hidden_boss', // 隐藏Boss\r\n    EVENT = 'event',            // 随机事件\r\n    SHOP = 'shop',              // 商店\r\n    TREASURE = 'treasure',       // 宝藏\r\n    CAMPFIRE = 'campfire',      // 篝火(休息)\r\n    UPGRADE = 'upgrade',        // 升级台\r\n    MYSTERY = 'mystery',        // 神秘节点\r\n    START = 'start',            // 起始节点\r\n    END = 'end'                 // 结束节点\r\n}\r\n\r\nexport enum ChapterTheme {\r\n    FOREST = 'forest',          // 第一章：森林\r\n    MOUNTAIN = 'mountain',      // 第二章：山脉  \r\n    ABYSS = 'abyss'            // 第三章：深渊\r\n}\r\n\r\ninterface MapNode {\r\n    id: string;\r\n    type: NodeType;\r\n    position: Vec3;\r\n    connections: string[];     // 连接的节点ID\r\n    isVisited: boolean;\r\n    isAvailable: boolean;\r\n    isCurrentPath: boolean;\r\n    chapter: number;\r\n    floor: number;\r\n    \r\n    // Node-specific data\r\n    combatData?: {\r\n        difficulty: number;\r\n        brickCount: number;\r\n        specialBrickRatio: number;\r\n    };\r\n    \r\n    eliteData?: {\r\n        eliteType: EliteType;\r\n        difficulty: number;\r\n    };\r\n    \r\n    bossData?: {\r\n        bossType: BossType;\r\n        chapter: number;\r\n    };\r\n    \r\n    eventData?: {\r\n        eventType: string;\r\n        choices: EventChoice[];\r\n    };\r\n    \r\n    shopData?: {\r\n        items: ShopItem[];\r\n        currency: number;\r\n    };\r\n    \r\n    treasureData?: {\r\n        rewardType: string;\r\n        rewardValue: any;\r\n    };\r\n}\r\n\r\ninterface EventChoice {\r\n    id: string;\r\n    text: string;\r\n    requirements?: string[];\r\n    consequences: EventConsequence[];\r\n}\r\n\r\ninterface EventConsequence {\r\n    type: 'health' | 'relic' | 'currency' | 'experience' | 'curse';\r\n    value: any;\r\n    description: string;\r\n}\r\n\r\ninterface ShopItem {\r\n    id: string;\r\n    name: string;\r\n    description: string;\r\n    type: 'relic' | 'upgrade' | 'consumable';\r\n    cost: number;\r\n    data: any;\r\n}\r\n\r\n@ccclass('MapManager')  \r\nexport class MapManager extends Component {\r\n    @property({type: Prefab})\r\n    public mapNodePrefab: Prefab | null = null;\r\n    \r\n    @property({type: Prefab})\r\n    public connectionLinePrefab: Prefab | null = null;\r\n    \r\n    @property\r\n    public nodesPerFloor: number = 4;\r\n    \r\n    @property\r\n    public floorsPerChapter: number = 15;\r\n    \r\n    @property\r\n    public nodeSpacing: number = 150;\r\n    \r\n    @property\r\n    public floorSpacing: number = 100;\r\n    \r\n    // Map state\r\n    private _currentChapter: number = 1;\r\n    private _currentFloor: number = 0;\r\n    private _currentNodeId: string = '';\r\n    private _mapNodes: Map<string, MapNode> = new Map();\r\n    private _completedNodes: MapNode[] = [];\r\n    private _chapterTheme: ChapterTheme = ChapterTheme.FOREST;\r\n    \r\n    // Map generation parameters\r\n    private _nodeTypeDistribution: Map<NodeType, number> = new Map();\r\n    private _chapterBossTypes: Map<number, BossType[]> = new Map();\r\n    private _availableEliteTypes: EliteType[] = [];\r\n    \r\n    // Visual elements\r\n    private _nodeVisuals: Map<string, Node> = new Map();\r\n    private _connectionLines: Node[] = [];\r\n    \r\n    protected onLoad(): void {\r\n        this.initializeNodeDistribution();\r\n        this.initializeChapterBosses();\r\n        this.loadMapProgress();\r\n    }\r\n    \r\n    protected start(): void {\r\n        this.generateChapterMap(1);\r\n    }\r\n    \r\n    private initializeNodeDistribution(): void {\r\n        // Distribution for regular floors (not boss floors)\r\n        this._nodeTypeDistribution.set(NodeType.COMBAT, 45);      // 45% 普通战斗\r\n        this._nodeTypeDistribution.set(NodeType.ELITE, 15);       // 15% 精英战斗\r\n        this._nodeTypeDistribution.set(NodeType.EVENT, 15);       // 15% 随机事件\r\n        this._nodeTypeDistribution.set(NodeType.SHOP, 8);         // 8% 商店\r\n        this._nodeTypeDistribution.set(NodeType.TREASURE, 7);     // 7% 宝藏\r\n        this._nodeTypeDistribution.set(NodeType.CAMPFIRE, 5);     // 5% 篝火休息\r\n        this._nodeTypeDistribution.set(NodeType.UPGRADE, 3);      // 3% 升级台\r\n        this._nodeTypeDistribution.set(NodeType.MYSTERY, 2);      // 2% 神秘节点\r\n    }\r\n    \r\n    private initializeChapterBosses(): void {\r\n        // Chapter 1 bosses\r\n        this._chapterBossTypes.set(1, [\r\n            BossType.GUARDIAN_WALL,\r\n            BossType.STORM_CALLER,\r\n            BossType.BRICK_SPAWNER\r\n        ]);\r\n        \r\n        // Chapter 2 bosses  \r\n        this._chapterBossTypes.set(2, [\r\n            BossType.GRAVITY_MASTER,\r\n            BossType.TIME_MANIPULATOR,\r\n            BossType.SHIELD_GENERATOR\r\n        ]);\r\n        \r\n        // Chapter 3 bosses\r\n        this._chapterBossTypes.set(3, [\r\n            BossType.MULTI_PHASE,\r\n            BossType.TELEPORTER,\r\n            BossType.ELEMENTAL_CHAOS,\r\n            BossType.MIRROR_BOSS\r\n        ]);\r\n        \r\n        // Initialize available elite types\r\n        this._availableEliteTypes = [\r\n            EliteType.BRICK_FORTRESS,\r\n            EliteType.SPEED_DEMON,\r\n            EliteType.REGENERATOR,\r\n            EliteType.ELEMENTAL_CHAOS,\r\n            EliteType.GRAVITY_ANOMALY,\r\n            EliteType.TIME_DISTORTION,\r\n            EliteType.PHASE_SHIFTER,\r\n            EliteType.MAGNETIC_STORM,\r\n            EliteType.SHIELD_MATRIX,\r\n            EliteType.VOID_CORRUPTION\r\n        ];\r\n    }\r\n    \r\n    public generateChapterMap(chapter: number): void {\r\n        this._currentChapter = chapter;\r\n        this._currentFloor = 0;\r\n        this._chapterTheme = this.getChapterTheme(chapter);\r\n        \r\n        console.log(`Generating Chapter ${chapter} Map: ${this._chapterTheme}`);\r\n        \r\n        // Clear existing map\r\n        this.clearCurrentMap();\r\n        \r\n        // Generate map structure\r\n        this.generateMapNodes();\r\n        this.generateConnections();\r\n        this.calculateAvailableNodes();\r\n        \r\n        // Create visual representation\r\n        this.createMapVisuals();\r\n        \r\n        // Set starting position\r\n        const startNodes = this.getNodesByType(NodeType.START);\r\n        if (startNodes.length > 0) {\r\n            this._currentNodeId = startNodes[0].id;\r\n            this.updateNodeAvailability();\r\n        }\r\n    }\r\n    \r\n    private generateMapNodes(): void {\r\n        this._mapNodes.clear();\r\n        \r\n        // Generate each floor\r\n        for (let floor = 0; floor < this.floorsPerChapter; floor++) {\r\n            this.generateFloorNodes(floor);\r\n        }\r\n        \r\n        console.log(`Generated ${this._mapNodes.size} nodes for Chapter ${this._currentChapter}`);\r\n    }\r\n    \r\n    private generateFloorNodes(floor: number): void {\r\n        const nodeCount = this.getNodeCountForFloor(floor);\r\n        \r\n        if (floor === 0) {\r\n            // Start floor - single start node\r\n            this.createNode('start_0', NodeType.START, floor, 0);\r\n        } else if (floor === this.floorsPerChapter - 1) {\r\n            // Boss floor\r\n            const bossTypes = this._chapterBossTypes.get(this._currentChapter) || [];\r\n            const randomBoss = bossTypes[Math.floor(Math.random() * bossTypes.length)];\r\n            \r\n            const bossNode = this.createNode(`boss_${floor}`, NodeType.BOSS, floor, 0);\r\n            bossNode.bossData = {\r\n                bossType: randomBoss,\r\n                chapter: this._currentChapter\r\n            };\r\n        } else if (floor === this.floorsPerChapter - 2) {\r\n            // Pre-boss floor - always has campfire and shop\r\n            this.createNode(`campfire_${floor}_0`, NodeType.CAMPFIRE, floor, 0);\r\n            this.createNode(`shop_${floor}_1`, NodeType.SHOP, floor, 1);\r\n            \r\n            // Fill remaining slots with combat\r\n            for (let i = 2; i < nodeCount; i++) {\r\n                this.createCombatNode(`combat_${floor}_${i}`, floor, i);\r\n            }\r\n        } else {\r\n            // Regular floors\r\n            this.generateRegularFloor(floor, nodeCount);\r\n        }\r\n    }\r\n    \r\n    private generateRegularFloor(floor: number, nodeCount: number): void {\r\n        const nodesToCreate: NodeType[] = [];\r\n        \r\n        // Determine node types for this floor\r\n        for (let i = 0; i < nodeCount; i++) {\r\n            const nodeType = this.selectRandomNodeType();\r\n            nodesToCreate.push(nodeType);\r\n        }\r\n        \r\n        // Ensure at least one combat node per floor\r\n        if (!nodesToCreate.includes(NodeType.COMBAT)) {\r\n            nodesToCreate[Math.floor(Math.random() * nodesToCreate.length)] = NodeType.COMBAT;\r\n        }\r\n        \r\n        // Create nodes\r\n        for (let i = 0; i < nodeCount; i++) {\r\n            const nodeId = `${nodesToCreate[i]}_${floor}_${i}`;\r\n            this.createNodeByType(nodeId, nodesToCreate[i], floor, i);\r\n        }\r\n    }\r\n    \r\n    private createNodeByType(nodeId: string, nodeType: NodeType, floor: number, position: number): void {\r\n        const node = this.createNode(nodeId, nodeType, floor, position);\r\n        \r\n        switch (nodeType) {\r\n            case NodeType.COMBAT:\r\n                this.setupCombatNode(node, floor);\r\n                break;\r\n            case NodeType.ELITE:\r\n                this.setupEliteNode(node, floor);\r\n                break;\r\n            case NodeType.EVENT:\r\n                this.setupEventNode(node, floor);\r\n                break;\r\n            case NodeType.SHOP:\r\n                this.setupShopNode(node, floor);\r\n                break;\r\n            case NodeType.TREASURE:\r\n                this.setupTreasureNode(node, floor);\r\n                break;\r\n            case NodeType.MYSTERY:\r\n                this.setupMysteryNode(node, floor);\r\n                break;\r\n        }\r\n    }\r\n    \r\n    private createNode(nodeId: string, nodeType: NodeType, floor: number, position: number): MapNode {\r\n        const node: MapNode = {\r\n            id: nodeId,\r\n            type: nodeType,\r\n            position: new Vec3(\r\n                (position - (this.getNodeCountForFloor(floor) - 1) / 2) * this.nodeSpacing,\r\n                floor * this.floorSpacing,\r\n                0\r\n            ),\r\n            connections: [],\r\n            isVisited: false,\r\n            isAvailable: floor === 0, // Only start nodes are initially available\r\n            isCurrentPath: false,\r\n            chapter: this._currentChapter,\r\n            floor: floor\r\n        };\r\n        \r\n        this._mapNodes.set(nodeId, node);\r\n        return node;\r\n    }\r\n    \r\n    private createCombatNode(nodeId: string, floor: number, position: number): void {\r\n        const node = this.createNode(nodeId, NodeType.COMBAT, floor, position);\r\n        this.setupCombatNode(node, floor);\r\n    }\r\n    \r\n    private setupCombatNode(node: MapNode, floor: number): void {\r\n        const baseDifficulty = 1 + (this._currentChapter - 1) * 0.5 + floor * 0.1;\r\n        \r\n        node.combatData = {\r\n            difficulty: baseDifficulty,\r\n            brickCount: Math.floor(20 + baseDifficulty * 5),\r\n            specialBrickRatio: Math.min(0.4, 0.2 + baseDifficulty * 0.05)\r\n        };\r\n    }\r\n    \r\n    private setupEliteNode(node: MapNode, floor: number): void {\r\n        const randomElite = this._availableEliteTypes[\r\n            Math.floor(Math.random() * this._availableEliteTypes.length)\r\n        ];\r\n        \r\n        const baseDifficulty = 1 + (this._currentChapter - 1) * 0.5 + floor * 0.1;\r\n        \r\n        node.eliteData = {\r\n            eliteType: randomElite,\r\n            difficulty: baseDifficulty * 1.4\r\n        };\r\n    }\r\n    \r\n    private setupEventNode(node: MapNode, floor: number): void {\r\n        const events = this.getAvailableEvents(this._chapterTheme, floor);\r\n        const randomEvent = events[Math.floor(Math.random() * events.length)];\r\n        \r\n        node.eventData = {\r\n            eventType: randomEvent.type,\r\n            choices: randomEvent.choices\r\n        };\r\n    }\r\n    \r\n    private setupShopNode(node: MapNode, floor: number): void {\r\n        node.shopData = {\r\n            items: this.generateShopItems(floor),\r\n            currency: 0 // Player's currency will be checked when entering\r\n        };\r\n    }\r\n    \r\n    private setupTreasureNode(node: MapNode, floor: number): void {\r\n        const treasureTypes = ['relic', 'currency', 'upgrade_material'];\r\n        const randomType = treasureTypes[Math.floor(Math.random() * treasureTypes.length)];\r\n        \r\n        node.treasureData = {\r\n            rewardType: randomType,\r\n            rewardValue: this.generateTreasureReward(randomType, floor)\r\n        };\r\n    }\r\n    \r\n    private setupMysteryNode(node: MapNode, floor: number): void {\r\n        // Mystery nodes have random effects that are revealed when entered\r\n        node.treasureData = {\r\n            rewardType: 'mystery',\r\n            rewardValue: { floor: floor, chapter: this._currentChapter }\r\n        };\r\n    }\r\n    \r\n    private generateConnections(): void {\r\n        const nodesByFloor = this.groupNodesByFloor();\r\n        \r\n        for (let floor = 0; floor < this.floorsPerChapter - 1; floor++) {\r\n            const currentFloorNodes = nodesByFloor.get(floor) || [];\r\n            const nextFloorNodes = nodesByFloor.get(floor + 1) || [];\r\n            \r\n            this.connectFloors(currentFloorNodes, nextFloorNodes, floor);\r\n        }\r\n    }\r\n    \r\n    private connectFloors(currentFloor: MapNode[], nextFloor: MapNode[], floorIndex: number): void {\r\n        if (currentFloor.length === 0 || nextFloor.length === 0) return;\r\n        \r\n        // Each node in current floor connects to 1-3 nodes in next floor\r\n        for (const currentNode of currentFloor) {\r\n            const connectionCount = Math.min(\r\n                nextFloor.length,\r\n                Math.floor(Math.random() * 3) + 1\r\n            );\r\n            \r\n            // Choose random nodes to connect to, preferring nearby positions\r\n            const targetIndices = this.selectConnectionTargets(\r\n                currentFloor.indexOf(currentNode),\r\n                nextFloor.length,\r\n                connectionCount\r\n            );\r\n            \r\n            for (const targetIndex of targetIndices) {\r\n                const targetNode = nextFloor[targetIndex];\r\n                currentNode.connections.push(targetNode.id);\r\n            }\r\n        }\r\n        \r\n        // Ensure all next floor nodes are reachable\r\n        this.ensureNodesReachable(currentFloor, nextFloor);\r\n    }\r\n    \r\n    private selectConnectionTargets(sourceIndex: number, targetCount: number, connectionCount: number): number[] {\r\n        const targets: number[] = [];\r\n        const sourcePosition = sourceIndex / Math.max(1, targetCount - 1); // Normalize to 0-1\r\n        \r\n        // Prefer connections to nearby nodes\r\n        for (let i = 0; i < connectionCount; i++) {\r\n            let targetIndex: number;\r\n            \r\n            if (i === 0) {\r\n                // First connection: closest node\r\n                targetIndex = Math.round(sourcePosition * (targetCount - 1));\r\n            } else {\r\n                // Additional connections: random nearby nodes\r\n                const range = Math.min(2, Math.floor(targetCount / 2));\r\n                const centerIndex = Math.round(sourcePosition * (targetCount - 1));\r\n                const minIndex = Math.max(0, centerIndex - range);\r\n                const maxIndex = Math.min(targetCount - 1, centerIndex + range);\r\n                \r\n                do {\r\n                    targetIndex = Math.floor(Math.random() * (maxIndex - minIndex + 1)) + minIndex;\r\n                } while (targets.includes(targetIndex));\r\n            }\r\n            \r\n            targets.push(targetIndex);\r\n        }\r\n        \r\n        return targets;\r\n    }\r\n    \r\n    private ensureNodesReachable(currentFloor: MapNode[], nextFloor: MapNode[]): void {\r\n        const reachableNodes = new Set<string>();\r\n        \r\n        // Find all reachable nodes\r\n        for (const currentNode of currentFloor) {\r\n            for (const connectionId of currentNode.connections) {\r\n                reachableNodes.add(connectionId);\r\n            }\r\n        }\r\n        \r\n        // Connect unreachable nodes to random current floor nodes\r\n        for (const nextNode of nextFloor) {\r\n            if (!reachableNodes.has(nextNode.id)) {\r\n                const randomCurrentNode = currentFloor[Math.floor(Math.random() * currentFloor.length)];\r\n                randomCurrentNode.connections.push(nextNode.id);\r\n            }\r\n        }\r\n    }\r\n    \r\n    private createMapVisuals(): void {\r\n        this.clearMapVisuals();\r\n        \r\n        // Create node visuals\r\n        for (const [nodeId, node] of this._mapNodes) {\r\n            this.createNodeVisual(node);\r\n        }\r\n        \r\n        // Create connection lines\r\n        this.createConnectionVisuals();\r\n    }\r\n    \r\n    private createNodeVisual(node: MapNode): void {\r\n        if (!this.mapNodePrefab) return;\r\n        \r\n        const nodeVisual = instantiate(this.mapNodePrefab);\r\n        const sprite = nodeVisual.getComponent(Sprite);\r\n        const label = nodeVisual.getComponentInChildren(Label);\r\n        const button = nodeVisual.getComponent(Button);\r\n        \r\n        if (sprite) {\r\n            sprite.color = this.getNodeColor(node.type);\r\n        }\r\n        \r\n        if (label) {\r\n            label.string = this.getNodeDisplayName(node.type);\r\n        }\r\n        \r\n        if (button) {\r\n            button.node.on(Button.EventType.CLICK, () => this.onNodeClicked(node.id), this);\r\n        }\r\n        \r\n        nodeVisual.setParent(this.node);\r\n        nodeVisual.setPosition(node.position);\r\n        \r\n        // Set availability visual state\r\n        this.updateNodeVisualState(nodeVisual, node);\r\n        \r\n        this._nodeVisuals.set(node.id, nodeVisual);\r\n    }\r\n    \r\n    private createConnectionVisuals(): void {\r\n        if (!this.connectionLinePrefab) return;\r\n        \r\n        for (const [nodeId, node] of this._mapNodes) {\r\n            for (const connectionId of node.connections) {\r\n                const targetNode = this._mapNodes.get(connectionId);\r\n                if (!targetNode) continue;\r\n                \r\n                const line = instantiate(this.connectionLinePrefab);\r\n                line.setParent(this.node);\r\n                \r\n                // Position and scale line between nodes\r\n                const startPos = node.position;\r\n                const endPos = targetNode.position;\r\n                const midPos = Vec3.lerp(new Vec3(), startPos, endPos, 0.5);\r\n                const distance = Vec3.distance(startPos, endPos);\r\n                \r\n                line.setPosition(midPos);\r\n                \r\n                const transform = line.getComponent(UITransform);\r\n                if (transform) {\r\n                    transform.width = distance;\r\n                    \r\n                    // Rotate line to connect nodes\r\n                    const angle = Math.atan2(endPos.y - startPos.y, endPos.x - startPos.x);\r\n                    line.setRotationFromEuler(0, 0, angle * 180 / Math.PI);\r\n                }\r\n                \r\n                this._connectionLines.push(line);\r\n            }\r\n        }\r\n    }\r\n    \r\n    private getNodeColor(nodeType: NodeType): Color {\r\n        switch (nodeType) {\r\n            case NodeType.COMBAT: return new Color(150, 150, 150); // Gray\r\n            case NodeType.ELITE: return new Color(255, 165, 0);    // Orange\r\n            case NodeType.BOSS: return new Color(255, 0, 0);       // Red\r\n            case NodeType.EVENT: return new Color(0, 255, 255);    // Cyan\r\n            case NodeType.SHOP: return new Color(255, 255, 0);     // Yellow\r\n            case NodeType.TREASURE: return new Color(255, 215, 0); // Gold\r\n            case NodeType.CAMPFIRE: return new Color(255, 100, 0); // Orange-red\r\n            case NodeType.UPGRADE: return new Color(128, 0, 128);  // Purple\r\n            case NodeType.MYSTERY: return new Color(128, 128, 255); // Light blue\r\n            case NodeType.START: return new Color(0, 255, 0);      // Green\r\n            default: return new Color(255, 255, 255);              // White\r\n        }\r\n    }\r\n    \r\n    private getNodeDisplayName(nodeType: NodeType): string {\r\n        switch (nodeType) {\r\n            case NodeType.COMBAT: return \"战斗\";\r\n            case NodeType.ELITE: return \"精英\";\r\n            case NodeType.BOSS: return \"BOSS\";\r\n            case NodeType.EVENT: return \"事件\";\r\n            case NodeType.SHOP: return \"商店\";\r\n            case NodeType.TREASURE: return \"宝藏\";\r\n            case NodeType.CAMPFIRE: return \"篝火\";\r\n            case NodeType.UPGRADE: return \"升级\";\r\n            case NodeType.MYSTERY: return \"神秘\";\r\n            case NodeType.START: return \"开始\";\r\n            default: return \"未知\";\r\n        }\r\n    }\r\n    \r\n    public onNodeClicked(nodeId: string): void {\r\n        const node = this._mapNodes.get(nodeId);\r\n        if (!node || !node.isAvailable) {\r\n            console.log(`Node ${nodeId} is not available`);\r\n            return;\r\n        }\r\n        \r\n        console.log(`Player selected node: ${nodeId} (${node.type})`);\r\n        \r\n        // Mark current node as visited\r\n        node.isVisited = true;\r\n        node.isCurrentPath = true;\r\n        this._currentNodeId = nodeId;\r\n        \r\n        // Update node availability\r\n        this.updateNodeAvailability();\r\n        \r\n        // Trigger node action\r\n        this.executeNodeAction(node);\r\n        \r\n        // Update visuals\r\n        this.updateAllNodeVisuals();\r\n    }\r\n    \r\n    private executeNodeAction(node: MapNode): void {\r\n        switch (node.type) {\r\n            case NodeType.COMBAT:\r\n                this.startCombat(node);\r\n                break;\r\n            case NodeType.ELITE:\r\n                this.startEliteCombat(node);\r\n                break;\r\n            case NodeType.BOSS:\r\n                this.startBossCombat(node);\r\n                break;\r\n            case NodeType.EVENT:\r\n                this.triggerEvent(node);\r\n                break;\r\n            case NodeType.SHOP:\r\n                this.enterShop(node);\r\n                break;\r\n            case NodeType.TREASURE:\r\n                this.openTreasure(node);\r\n                break;\r\n            case NodeType.CAMPFIRE:\r\n                this.restAtCampfire(node);\r\n                break;\r\n            case NodeType.UPGRADE:\r\n                this.enterUpgradeStation(node);\r\n                break;\r\n            case NodeType.MYSTERY:\r\n                this.encounterMystery(node);\r\n                break;\r\n        }\r\n    }\r\n    \r\n    // Node action implementations\r\n    private startCombat(node: MapNode): void {\r\n        console.log(`Starting combat with difficulty ${node.combatData?.difficulty}`);\r\n        // Integrate with GameManager to start combat\r\n    }\r\n    \r\n    private startEliteCombat(node: MapNode): void {\r\n        console.log(`Starting elite combat: ${node.eliteData?.eliteType}`);\r\n        // Integrate with EliteAndHiddenBossManager\r\n    }\r\n    \r\n    private startBossCombat(node: MapNode): void {\r\n        console.log(`Starting boss combat: ${node.bossData?.bossType}`);\r\n        // Integrate with EnhancedBossController\r\n    }\r\n    \r\n    private triggerEvent(node: MapNode): void {\r\n        console.log(`Triggered event: ${node.eventData?.eventType}`);\r\n        // Show event UI with choices\r\n    }\r\n    \r\n    private enterShop(node: MapNode): void {\r\n        console.log(`Entered shop with ${node.shopData?.items.length} items`);\r\n        // Show shop UI\r\n    }\r\n    \r\n    private openTreasure(node: MapNode): void {\r\n        console.log(`Found treasure: ${node.treasureData?.rewardType}`);\r\n        // Award treasure and show UI\r\n    }\r\n    \r\n    private restAtCampfire(node: MapNode): void {\r\n        console.log('Resting at campfire');\r\n        // Restore health, show rest options\r\n    }\r\n    \r\n    private enterUpgradeStation(node: MapNode): void {\r\n        console.log('Entered upgrade station');\r\n        // Show upgrade options\r\n    }\r\n    \r\n    private encounterMystery(node: MapNode): void {\r\n        console.log('Encountered mystery node');\r\n        // Random effect\r\n    }\r\n    \r\n    // Utility methods\r\n    private selectRandomNodeType(): NodeType {\r\n        const totalWeight = Array.from(this._nodeTypeDistribution.values()).reduce((sum, weight) => sum + weight, 0);\r\n        let random = Math.random() * totalWeight;\r\n        \r\n        for (const [nodeType, weight] of this._nodeTypeDistribution.entries()) {\r\n            random -= weight;\r\n            if (random <= 0) {\r\n                return nodeType;\r\n            }\r\n        }\r\n        \r\n        return NodeType.COMBAT; // Fallback\r\n    }\r\n    \r\n    private getNodeCountForFloor(floor: number): number {\r\n        if (floor === 0 || floor === this.floorsPerChapter - 1) {\r\n            return 1; // Start and boss floors have single nodes\r\n        } else if (floor === this.floorsPerChapter - 2) {\r\n            return this.nodesPerFloor - 1; // Pre-boss floor has slightly fewer options\r\n        } else {\r\n            return this.nodesPerFloor;\r\n        }\r\n    }\r\n    \r\n    private getChapterTheme(chapter: number): ChapterTheme {\r\n        switch (chapter) {\r\n            case 1: return ChapterTheme.FOREST;\r\n            case 2: return ChapterTheme.MOUNTAIN;\r\n            case 3: return ChapterTheme.ABYSS;\r\n            default: return ChapterTheme.FOREST;\r\n        }\r\n    }\r\n    \r\n    private groupNodesByFloor(): Map<number, MapNode[]> {\r\n        const floorGroups = new Map<number, MapNode[]>();\r\n        \r\n        for (const node of this._mapNodes.values()) {\r\n            if (!floorGroups.has(node.floor)) {\r\n                floorGroups.set(node.floor, []);\r\n            }\r\n            floorGroups.get(node.floor)!.push(node);\r\n        }\r\n        \r\n        return floorGroups;\r\n    }\r\n    \r\n    private getNodesByType(nodeType: NodeType): MapNode[] {\r\n        return Array.from(this._mapNodes.values()).filter(node => node.type === nodeType);\r\n    }\r\n    \r\n    private updateNodeAvailability(): void {\r\n        // Reset availability\r\n        for (const node of this._mapNodes.values()) {\r\n            node.isAvailable = false;\r\n        }\r\n        \r\n        // Make connected nodes available\r\n        const currentNode = this._mapNodes.get(this._currentNodeId);\r\n        if (currentNode) {\r\n            for (const connectionId of currentNode.connections) {\r\n                const connectedNode = this._mapNodes.get(connectionId);\r\n                if (connectedNode && !connectedNode.isVisited) {\r\n                    connectedNode.isAvailable = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    private updateAllNodeVisuals(): void {\r\n        for (const [nodeId, node] of this._mapNodes) {\r\n            const visual = this._nodeVisuals.get(nodeId);\r\n            if (visual) {\r\n                this.updateNodeVisualState(visual, node);\r\n            }\r\n        }\r\n    }\r\n    \r\n    private updateNodeVisualState(visual: Node, node: MapNode): void {\r\n        const sprite = visual.getComponent(Sprite);\r\n        if (!sprite) return;\r\n        \r\n        if (node.isVisited) {\r\n            sprite.color = new Color(100, 100, 100, 180); // Dark and semi-transparent\r\n        } else if (node.isAvailable) {\r\n            sprite.color = this.getNodeColor(node.type);\r\n        } else {\r\n            sprite.color = new Color(80, 80, 80, 100); // Very dark and transparent\r\n        }\r\n        \r\n        // Highlight current node\r\n        if (node.id === this._currentNodeId) {\r\n            sprite.color = Color.WHITE;\r\n        }\r\n    }\r\n    \r\n    private clearCurrentMap(): void {\r\n        this._mapNodes.clear();\r\n        this.clearMapVisuals();\r\n    }\r\n    \r\n    private clearMapVisuals(): void {\r\n        // Clear node visuals\r\n        for (const visual of this._nodeVisuals.values()) {\r\n            visual.destroy();\r\n        }\r\n        this._nodeVisuals.clear();\r\n        \r\n        // Clear connection lines\r\n        for (const line of this._connectionLines) {\r\n            line.destroy();\r\n        }\r\n        this._connectionLines = [];\r\n    }\r\n    \r\n    // Event and shop data generation\r\n    private getAvailableEvents(theme: ChapterTheme, floor: number): any[] {\r\n        // This would be expanded with actual event data\r\n        return [\r\n            {\r\n                type: 'mysterious_shrine',\r\n                choices: [\r\n                    {\r\n                        id: 'pray',\r\n                        text: '祈祷获得祝福',\r\n                        consequences: [{ type: 'relic', value: 'random', description: '获得随机遗物' }]\r\n                    },\r\n                    {\r\n                        id: 'ignore',\r\n                        text: '无视神龛',\r\n                        consequences: [{ type: 'currency', value: 20, description: '获得20金币' }]\r\n                    }\r\n                ]\r\n            }\r\n        ];\r\n    }\r\n    \r\n    private generateShopItems(floor: number): ShopItem[] {\r\n        // Generate shop items based on floor and chapter\r\n        return [\r\n            {\r\n                id: 'health_potion',\r\n                name: '生命药水',\r\n                description: '恢复50点生命值',\r\n                type: 'consumable',\r\n                cost: 75,\r\n                data: { healing: 50 }\r\n            },\r\n            {\r\n                id: 'damage_relic',\r\n                name: '力量护符',\r\n                description: '永久增加10%伤害',\r\n                type: 'relic',\r\n                cost: 150,\r\n                data: { damageBonus: 0.1 }\r\n            }\r\n        ];\r\n    }\r\n    \r\n    private generateTreasureReward(rewardType: string, floor: number): any {\r\n        switch (rewardType) {\r\n            case 'relic':\r\n                return { relicType: 'random', tier: 'common' };\r\n            case 'currency':\r\n                return { amount: 50 + floor * 10 };\r\n            case 'upgrade_material':\r\n                return { type: 'enhancement_stone', quantity: 2 };\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n    \r\n    private saveMapProgress(): void {\r\n        // Save current map state\r\n        console.log('Map progress saved');\r\n    }\r\n    \r\n    private loadMapProgress(): void {\r\n        // Load saved map state\r\n        console.log('Map progress loaded');\r\n    }\r\n    \r\n    // Public accessors\r\n    public getCurrentNode(): MapNode | undefined {\r\n        return this._mapNodes.get(this._currentNodeId);\r\n    }\r\n    \r\n    public getCurrentChapter(): number {\r\n        return this._currentChapter;\r\n    }\r\n    \r\n    public getCurrentFloor(): number {\r\n        const currentNode = this.getCurrentNode();\r\n        return currentNode ? currentNode.floor : 0;\r\n    }\r\n    \r\n    public isChapterComplete(): boolean {\r\n        const currentNode = this.getCurrentNode();\r\n        return currentNode?.type === NodeType.BOSS && currentNode.isVisited;\r\n    }\r\n    \r\n    public getNextChapterAvailable(): boolean {\r\n        return this.isChapterComplete() && this._currentChapter < 3;\r\n    }\r\n    \r\n    private calculateAvailableNodes(): void {\r\n        // Calculate which nodes are available based on current progress\r\n        // Initially only starting nodes are available\r\n        for (const [nodeId, node] of this._mapNodes) {\r\n            if (node.type === NodeType.START) {\r\n                node.isAvailable = true;\r\n            } else {\r\n                node.isAvailable = false;\r\n            }\r\n        }\r\n        \r\n        // Update available nodes based on completed nodes\r\n        this.updateAvailableNodes();\r\n    }\r\n    \r\n    private updateAvailableNodes(): void {\r\n        // Unlock nodes that are connected to completed nodes\r\n        for (const completedNode of this._completedNodes) {\r\n            for (const connectionId of completedNode.connections) {\r\n                const connectedNode = this.getNodeById(connectionId);\r\n                if (connectedNode) {\r\n                    connectedNode.isAvailable = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    private getNodeById(nodeId: string): MapNode | undefined {\r\n        return this._mapNodes.get(nodeId);\r\n    }\r\n}"]}