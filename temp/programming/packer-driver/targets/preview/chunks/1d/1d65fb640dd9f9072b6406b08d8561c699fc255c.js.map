{"version":3,"sources":["file:///D:/project/claudecode/wx/Cat_Journey/assets/scripts/ExperienceOrb.ts"],"names":["_decorator","Component","RigidBody2D","Vec3","Vec2","Collider2D","Contact2DType","ccclass","property","ExperienceOrb","_rigidBody","_paddleNode","_coreNode","_isBeingAttracted","onLoad","getComponent","collider","on","BEGIN_CONTACT","onBeginContact","scheduleOnce","node","isValid","destroy","lifeTime","start","findTargets","setInitialVelocity","update","dt","updateMagnetism","gameManager","require","GameManager","getInstance","coreNode","randomX","Math","random","linearVelocity","fallSpeed","currentPos","position","closestTarget","closestDistance","Infinity","paddleDistance","distance","magnetRange","coreDistance","attractToTarget","target","targetPos","direction","subtract","normalize","attractionForce","attractionVelocity","multiplyScalar","x","y","selfCollider","otherCollider","contact","otherNode","name","includes","onCollected","console","log","experienceValue","coreController","addExperience","showCollectionEffect","sprite","color","r","g","b","a","getExperienceValue","setExperienceValue","value"],"mappings":"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","sourcesContent":["import { _decorator, Component, Node, RigidBody2D, Vec3, Vec2, Collider2D, Contact2DType, IPhysics2DContact } from 'cc';\r\n\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('ExperienceOrb')\r\nexport class ExperienceOrb extends Component {\r\n    @property\r\n    public fallSpeed: number = 200.0;\r\n    \r\n    @property\r\n    public experienceValue: number = 10;\r\n    \r\n    @property\r\n    public lifeTime: number = 8.0; // Auto-destroy after 8 seconds\r\n    \r\n    @property\r\n    public magnetRange: number = 150.0; // Range at which orb is attracted to paddle/core\r\n    \r\n    private _rigidBody: RigidBody2D | null = null;\r\n    private _paddleNode: Node | null = null;\r\n    private _coreNode: Node | null = null;\r\n    private _isBeingAttracted: boolean = false;\r\n    \r\n    protected onLoad(): void {\r\n        this._rigidBody = this.getComponent(RigidBody2D);\r\n        \r\n        const collider = this.getComponent(Collider2D);\r\n        if (collider) {\r\n            collider.on(Contact2DType.BEGIN_CONTACT, this.onBeginContact, this);\r\n        }\r\n        \r\n        // Auto-destroy after lifetime expires\r\n        this.scheduleOnce(() => {\r\n            if (this.node && this.node.isValid) {\r\n                this.node.destroy();\r\n            }\r\n        }, this.lifeTime);\r\n    }\r\n    \r\n    protected start(): void {\r\n        this.findTargets();\r\n        this.setInitialVelocity();\r\n    }\r\n    \r\n    protected update(dt: number): void {\r\n        this.updateMagnetism(dt);\r\n    }\r\n    \r\n    private findTargets(): void {\r\n        // Find paddle and core nodes for magnetism\r\n        const gameManager = require('./GameManager').GameManager.getInstance();\r\n        if (gameManager) {\r\n            this._paddleNode = (gameManager as any)._paddleNode;\r\n            this._coreNode = (gameManager as any).coreNode;\r\n        }\r\n    }\r\n    \r\n    private setInitialVelocity(): void {\r\n        if (this._rigidBody) {\r\n            // Start falling down with slight random horizontal movement\r\n            const randomX = (Math.random() - 0.5) * 50;\r\n            this._rigidBody.linearVelocity = new Vec2(randomX, -this.fallSpeed);\r\n        }\r\n    }\r\n    \r\n    private updateMagnetism(dt: number): void {\r\n        if (this._isBeingAttracted) return;\r\n        \r\n        const currentPos = this.node.position;\r\n        let closestTarget: Node | null = null;\r\n        let closestDistance = Infinity;\r\n        \r\n        // Check distance to paddle\r\n        if (this._paddleNode && this._paddleNode.isValid) {\r\n            const paddleDistance = Vec3.distance(currentPos, this._paddleNode.position);\r\n            if (paddleDistance < this.magnetRange && paddleDistance < closestDistance) {\r\n                closestTarget = this._paddleNode;\r\n                closestDistance = paddleDistance;\r\n            }\r\n        }\r\n        \r\n        // Check distance to core\r\n        if (this._coreNode && this._coreNode.isValid) {\r\n            const coreDistance = Vec3.distance(currentPos, this._coreNode.position);\r\n            if (coreDistance < this.magnetRange && coreDistance < closestDistance) {\r\n                closestTarget = this._coreNode;\r\n                closestDistance = coreDistance;\r\n            }\r\n        }\r\n        \r\n        // Apply magnetism if target found\r\n        if (closestTarget && this._rigidBody) {\r\n            this._isBeingAttracted = true;\r\n            this.attractToTarget(closestTarget);\r\n        }\r\n    }\r\n    \r\n    private attractToTarget(target: Node): void {\r\n        if (!this._rigidBody) return;\r\n        \r\n        const currentPos = this.node.position;\r\n        const targetPos = target.position;\r\n        \r\n        // Calculate direction to target\r\n        const direction = new Vec3();\r\n        Vec3.subtract(direction, targetPos, currentPos);\r\n        direction.normalize();\r\n        \r\n        // Apply attraction force\r\n        const attractionForce = 500; // Strong attraction\r\n        const attractionVelocity = Vec3.multiplyScalar(new Vec3(), direction, attractionForce);\r\n        this._rigidBody.linearVelocity = new Vec2(attractionVelocity.x, attractionVelocity.y);\r\n    }\r\n    \r\n    private onBeginContact(selfCollider: Collider2D, otherCollider: Collider2D, contact: IPhysics2DContact | null): void {\r\n        const otherNode = otherCollider.node;\r\n        \r\n        // Check if collected by paddle or core\r\n        if (otherNode.name.includes('Paddle') || otherNode.name.includes('Core')) {\r\n            this.onCollected();\r\n        }\r\n    }\r\n    \r\n    private onCollected(): void {\r\n        console.log(`Experience orb collected! Value: ${this.experienceValue}`);\r\n        \r\n        // Find core controller and add experience\r\n        if (this._coreNode) {\r\n            const coreController = this._coreNode.getComponent('CoreController');\r\n            if (coreController) {\r\n                (coreController as any).addExperience(this.experienceValue);\r\n            }\r\n        }\r\n        \r\n        this.showCollectionEffect();\r\n        \r\n        // Destroy the orb\r\n        this.node.destroy();\r\n    }\r\n    \r\n    private showCollectionEffect(): void {\r\n        // Visual feedback for collection\r\n        const sprite = this.getComponent('cc.Sprite');\r\n        if (sprite) {\r\n            // Quick flash before destruction\r\n            (sprite as any).color = { r: 255, g: 255, b: 255, a: 255 };\r\n        }\r\n        \r\n        // Could add particle effect or sound here\r\n        console.log('Experience orb collection effect played');\r\n    }\r\n    \r\n    public getExperienceValue(): number {\r\n        return this.experienceValue;\r\n    }\r\n    \r\n    public setExperienceValue(value: number): void {\r\n        this.experienceValue = value;\r\n    }\r\n}"]}