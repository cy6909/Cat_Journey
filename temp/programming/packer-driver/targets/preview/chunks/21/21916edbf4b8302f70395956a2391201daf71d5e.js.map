{"version":3,"sources":["file:///D:/project/claudecode/wx/Cat_Journey/assets/scripts/managers/MapManager.ts"],"names":["_decorator","Component","Vec3","Prefab","instantiate","Color","Sprite","Label","Button","UITransform","EliteType","BossType","ccclass","property","NodeType","MapNodeType","ChapterTheme","MapManager","type","_currentChapter","_currentFloor","_currentNodeId","_mapNodes","Map","_completedNodes","_chapterTheme","FOREST","_nodeTypeDistribution","_chapterBossTypes","_availableEliteTypes","_nodeVisuals","_connectionLines","getInstance","_instance","onLoad","initializeNodeDistribution","initializeChapterBosses","loadMapProgress","onDestroy","start","generateChapterMap","set","COMBAT","ELITE","EVENT","SHOP","TREASURE","CAMPFIRE","UPGRADE","MYSTERY","GUARDIAN_WALL","STORM_CALLER","BRICK_SPAWNER","GRAVITY_MASTER","TIME_MANIPULATOR","SHIELD_GENERATOR","MULTI_PHASE","TELEPORTER","ELEMENTAL_CHAOS","MIRROR_BOSS","BRICK_FORTRESS","SPEED_DEMON","REGENERATOR","GRAVITY_ANOMALY","TIME_DISTORTION","PHASE_SHIFTER","MAGNETIC_STORM","SHIELD_MATRIX","VOID_CORRUPTION","chapter","getChapterTheme","console","log","clearCurrentMap","generateMapNodes","generateConnections","calculateAvailableNodes","createMapVisuals","startNodes","getNodesByType","START","length","id","updateNodeAvailability","clear","floor","floorsPerChapter","generateFloorNodes","size","nodeCount","getNodeCountForFloor","createNode","bossTypes","get","randomBoss","Math","random","bossNode","BOSS","bossData","bossType","i","createCombatNode","generateRegularFloor","nodesToCreate","nodeType","selectRandomNodeType","push","includes","nodeId","createNodeByType","position","node","setupCombatNode","setupEliteNode","setupEventNode","setupShopNode","setupTreasureNode","setupMysteryNode","nodeSpacing","floorSpacing","connections","isVisited","isAvailable","isCurrentPath","baseDifficulty","combatData","difficulty","brickCount","specialBrickRatio","min","randomElite","eliteData","eliteType","events","getAvailableEvents","randomEvent","eventData","eventType","choices","shopData","items","generateShopItems","currency","treasureTypes","randomType","treasureData","rewardType","rewardValue","generateTreasureReward","nodesByFloor","groupNodesByFloor","currentFloorNodes","nextFloorNodes","connectFloors","currentFloor","nextFloor","_floorIndex","currentNode","connectionCount","targetIndices","selectConnectionTargets","indexOf","targetIndex","targetNode","ensureNodesReachable","sourceIndex","targetCount","targets","sourcePosition","max","round","range","centerIndex","minIndex","maxIndex","reachableNodes","Set","connectionId","add","nextNode","has","randomCurrentNode","clearMapVisuals","_nodeId","createNodeVisual","createConnectionVisuals","mapNodePrefab","nodeVisual","sprite","getComponent","label","getComponentInChildren","button","color","getNodeColor","string","getNodeDisplayName","on","EventType","CLICK","onNodeClicked","setParent","setPosition","updateNodeVisualState","connectionLinePrefab","line","startPos","endPos","midPos","lerp","distance","transform","width","angle","atan2","y","x","setRotationFromEuler","PI","executeNodeAction","updateAllNodeVisuals","startCombat","startEliteCombat","startBossCombat","triggerEvent","enterShop","openTreasure","restAtCampfire","enterUpgradeStation","encounterMystery","_node","totalWeight","Array","from","values","reduce","sum","weight","entries","nodesPerFloor","MOUNTAIN","ABYSS","floorGroups","filter","connectedNode","visual","WHITE","destroy","_theme","_floor","text","consequences","value","description","name","cost","data","healing","damageBonus","relicType","tier","amount","quantity","_saveMapProgress","getCurrentNode","getCurrentChapter","getCurrentFloor","isChapterComplete","getNextChapterAvailable","updateAvailableNodes","completedNode","getNodeById","getCurrentNodeType","getMapSize","getAvailableNodes","getCompletedNodesCount","canNavigateToNode","getNodeConnections","getShortestPath","fromNodeId","toNodeId","visited","queue","path","shift","getNodeData","getAllNodes","resetMap"],"mappings":"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","sourcesContent":["import { _decorator, Component, Node, Vec3, Prefab, instantiate, Color, Sprite, Label, Button, UITransform } from 'cc';\r\nimport { EliteType } from './EliteAndHiddenBossManager';\r\nimport { BossType } from '../gameplay/EnhancedBossController';\r\n\r\nconst { ccclass, property } = _decorator;\r\n\r\nexport enum NodeType {\r\n    COMBAT = 'combat',           // 普通战斗\r\n    ELITE = 'elite',            // 精英战斗\r\n    BOSS = 'boss',              // Boss战斗\r\n    HIDDEN_BOSS = 'hidden_boss', // 隐藏Boss\r\n    EVENT = 'event',            // 随机事件\r\n    SHOP = 'shop',              // 商店\r\n    TREASURE = 'treasure',       // 宝藏\r\n    CAMPFIRE = 'campfire',      // 篝火(休息)\r\n    UPGRADE = 'upgrade',        // 升级台\r\n    MYSTERY = 'mystery',        // 神秘节点\r\n    START = 'start',            // 起始节点\r\n    END = 'end',                // 结束节点\r\n    REST = 'rest',              // 休息节点 (alias for CAMPFIRE)\r\n    SECRET = 'secret',          // 秘密节点\r\n    MINI_BOSS = 'mini_boss',    // 小Boss\r\n    PUZZLE = 'puzzle',          // 谜题节点\r\n    GAUNTLET = 'gauntlet',      // 挑战节点\r\n    FINAL_BOSS = 'final_boss'   // 最终Boss\r\n}\r\n\r\n// 测试兼容性别名\r\nexport const MapNodeType = NodeType;\r\n\r\nexport enum ChapterTheme {\r\n    FOREST = 'forest',          // 第一章：森林\r\n    MOUNTAIN = 'mountain',      // 第二章：山脉  \r\n    ABYSS = 'abyss'            // 第三章：深渊\r\n}\r\n\r\ninterface MapNode {\r\n    id: string;\r\n    type: NodeType;\r\n    position: Vec3;\r\n    connections: string[];     // 连接的节点ID\r\n    isVisited: boolean;\r\n    isAvailable: boolean;\r\n    isCurrentPath: boolean;\r\n    chapter: number;\r\n    floor: number;\r\n    \r\n    // Node-specific data\r\n    combatData?: {\r\n        difficulty: number;\r\n        brickCount: number;\r\n        specialBrickRatio: number;\r\n    };\r\n    \r\n    eliteData?: {\r\n        eliteType: EliteType;\r\n        difficulty: number;\r\n    };\r\n    \r\n    bossData?: {\r\n        bossType: BossType;\r\n        chapter: number;\r\n    };\r\n    \r\n    eventData?: {\r\n        eventType: string;\r\n        choices: EventChoice[];\r\n    };\r\n    \r\n    shopData?: {\r\n        items: ShopItem[];\r\n        currency: number;\r\n    };\r\n    \r\n    treasureData?: {\r\n        rewardType: string;\r\n        rewardValue: any;\r\n    };\r\n}\r\n\r\ninterface EventChoice {\r\n    id: string;\r\n    text: string;\r\n    requirements?: string[];\r\n    consequences: EventConsequence[];\r\n}\r\n\r\ninterface EventConsequence {\r\n    type: 'health' | 'relic' | 'currency' | 'experience' | 'curse';\r\n    value: any;\r\n    description: string;\r\n}\r\n\r\ninterface ShopItem {\r\n    id: string;\r\n    name: string;\r\n    description: string;\r\n    type: 'relic' | 'upgrade' | 'consumable';\r\n    cost: number;\r\n    data: any;\r\n}\r\n\r\n@ccclass('MapManager')  \r\nexport class MapManager extends Component {\r\n    // 单例模式\r\n    private static _instance: MapManager | null = null;\r\n    \r\n    public static getInstance(): MapManager | null {\r\n        return MapManager._instance;\r\n    }\r\n    \r\n    @property({type: Prefab})\r\n    public mapNodePrefab: Prefab | null = null;\r\n    \r\n    @property({type: Prefab})\r\n    public connectionLinePrefab: Prefab | null = null;\r\n    \r\n    @property\r\n    public nodesPerFloor: number = 4;\r\n    \r\n    @property\r\n    public floorsPerChapter: number = 15;\r\n    \r\n    @property\r\n    public nodeSpacing: number = 150;\r\n    \r\n    @property\r\n    public floorSpacing: number = 100;\r\n    \r\n    // Map state\r\n    private _currentChapter: number = 1;\r\n    private _currentFloor: number = 0;\r\n    private _currentNodeId: string = '';\r\n    private _mapNodes: Map<string, MapNode> = new Map();\r\n    private _completedNodes: MapNode[] = [];\r\n    private _chapterTheme: ChapterTheme = ChapterTheme.FOREST;\r\n    \r\n    // Map generation parameters\r\n    private _nodeTypeDistribution: Map<NodeType, number> = new Map();\r\n    private _chapterBossTypes: Map<number, BossType[]> = new Map();\r\n    private _availableEliteTypes: EliteType[] = [];\r\n    \r\n    // Visual elements\r\n    private _nodeVisuals: Map<string, Node> = new Map();\r\n    private _connectionLines: Node[] = [];\r\n    \r\n    protected onLoad(): void {\r\n        if (MapManager._instance === null) {\r\n            MapManager._instance = this;\r\n        }\r\n        this.initializeNodeDistribution();\r\n        this.initializeChapterBosses();\r\n        this.loadMapProgress();\r\n    }\r\n\r\n    protected onDestroy(): void {\r\n        if (MapManager._instance === this) {\r\n            MapManager._instance = null;\r\n        }\r\n    }\r\n    \r\n    protected start(): void {\r\n        this.generateChapterMap(1);\r\n    }\r\n    \r\n    private initializeNodeDistribution(): void {\r\n        // Distribution for regular floors (not boss floors)\r\n        this._nodeTypeDistribution.set(NodeType.COMBAT, 45);      // 45% 普通战斗\r\n        this._nodeTypeDistribution.set(NodeType.ELITE, 15);       // 15% 精英战斗\r\n        this._nodeTypeDistribution.set(NodeType.EVENT, 15);       // 15% 随机事件\r\n        this._nodeTypeDistribution.set(NodeType.SHOP, 8);         // 8% 商店\r\n        this._nodeTypeDistribution.set(NodeType.TREASURE, 7);     // 7% 宝藏\r\n        this._nodeTypeDistribution.set(NodeType.CAMPFIRE, 5);     // 5% 篝火休息\r\n        this._nodeTypeDistribution.set(NodeType.UPGRADE, 3);      // 3% 升级台\r\n        this._nodeTypeDistribution.set(NodeType.MYSTERY, 2);      // 2% 神秘节点\r\n    }\r\n    \r\n    private initializeChapterBosses(): void {\r\n        // Chapter 1 bosses\r\n        this._chapterBossTypes.set(1, [\r\n            BossType.GUARDIAN_WALL,\r\n            BossType.STORM_CALLER,\r\n            BossType.BRICK_SPAWNER\r\n        ]);\r\n        \r\n        // Chapter 2 bosses  \r\n        this._chapterBossTypes.set(2, [\r\n            BossType.GRAVITY_MASTER,\r\n            BossType.TIME_MANIPULATOR,\r\n            BossType.SHIELD_GENERATOR\r\n        ]);\r\n        \r\n        // Chapter 3 bosses\r\n        this._chapterBossTypes.set(3, [\r\n            BossType.MULTI_PHASE,\r\n            BossType.TELEPORTER,\r\n            BossType.ELEMENTAL_CHAOS,\r\n            BossType.MIRROR_BOSS\r\n        ]);\r\n        \r\n        // Initialize available elite types\r\n        this._availableEliteTypes = [\r\n            EliteType.BRICK_FORTRESS,\r\n            EliteType.SPEED_DEMON,\r\n            EliteType.REGENERATOR,\r\n            EliteType.ELEMENTAL_CHAOS,\r\n            EliteType.GRAVITY_ANOMALY,\r\n            EliteType.TIME_DISTORTION,\r\n            EliteType.PHASE_SHIFTER,\r\n            EliteType.MAGNETIC_STORM,\r\n            EliteType.SHIELD_MATRIX,\r\n            EliteType.VOID_CORRUPTION\r\n        ];\r\n    }\r\n    \r\n    public generateChapterMap(chapter: number): void {\r\n        this._currentChapter = chapter;\r\n        this._currentFloor = 0;\r\n        this._chapterTheme = this.getChapterTheme(chapter);\r\n        \r\n        console.log(`Generating Chapter ${chapter} Map: ${this._chapterTheme}`);\r\n        \r\n        // Clear existing map\r\n        this.clearCurrentMap();\r\n        \r\n        // Generate map structure\r\n        this.generateMapNodes();\r\n        this.generateConnections();\r\n        this.calculateAvailableNodes();\r\n        \r\n        // Create visual representation\r\n        this.createMapVisuals();\r\n        \r\n        // Set starting position\r\n        const startNodes = this.getNodesByType(NodeType.START);\r\n        if (startNodes.length > 0) {\r\n            this._currentNodeId = startNodes[0].id;\r\n            this.updateNodeAvailability();\r\n        }\r\n    }\r\n    \r\n    private generateMapNodes(): void {\r\n        this._mapNodes.clear();\r\n        \r\n        // Generate each floor\r\n        for (let floor = 0; floor < this.floorsPerChapter; floor++) {\r\n            this.generateFloorNodes(floor);\r\n        }\r\n        \r\n        console.log(`Generated ${this._mapNodes.size} nodes for Chapter ${this._currentChapter}`);\r\n    }\r\n    \r\n    private generateFloorNodes(floor: number): void {\r\n        const nodeCount = this.getNodeCountForFloor(floor);\r\n        \r\n        if (floor === 0) {\r\n            // Start floor - single start node\r\n            this.createNode('start_0', NodeType.START, floor, 0);\r\n        } else if (floor === this.floorsPerChapter - 1) {\r\n            // Boss floor\r\n            const bossTypes = this._chapterBossTypes.get(this._currentChapter) || [];\r\n            const randomBoss = bossTypes[Math.floor(Math.random() * bossTypes.length)];\r\n            \r\n            const bossNode = this.createNode(`boss_${floor}`, NodeType.BOSS, floor, 0);\r\n            bossNode.bossData = {\r\n                bossType: randomBoss,\r\n                chapter: this._currentChapter\r\n            };\r\n        } else if (floor === this.floorsPerChapter - 2) {\r\n            // Pre-boss floor - always has campfire and shop\r\n            this.createNode(`campfire_${floor}_0`, NodeType.CAMPFIRE, floor, 0);\r\n            this.createNode(`shop_${floor}_1`, NodeType.SHOP, floor, 1);\r\n            \r\n            // Fill remaining slots with combat\r\n            for (let i = 2; i < nodeCount; i++) {\r\n                this.createCombatNode(`combat_${floor}_${i}`, floor, i);\r\n            }\r\n        } else {\r\n            // Regular floors\r\n            this.generateRegularFloor(floor, nodeCount);\r\n        }\r\n    }\r\n    \r\n    private generateRegularFloor(floor: number, nodeCount: number): void {\r\n        const nodesToCreate: NodeType[] = [];\r\n        \r\n        // Determine node types for this floor\r\n        for (let i = 0; i < nodeCount; i++) {\r\n            const nodeType = this.selectRandomNodeType();\r\n            nodesToCreate.push(nodeType);\r\n        }\r\n        \r\n        // Ensure at least one combat node per floor\r\n        if (!nodesToCreate.includes(NodeType.COMBAT)) {\r\n            nodesToCreate[Math.floor(Math.random() * nodesToCreate.length)] = NodeType.COMBAT;\r\n        }\r\n        \r\n        // Create nodes\r\n        for (let i = 0; i < nodeCount; i++) {\r\n            const nodeId = `${nodesToCreate[i]}_${floor}_${i}`;\r\n            this.createNodeByType(nodeId, nodesToCreate[i], floor, i);\r\n        }\r\n    }\r\n    \r\n    private createNodeByType(nodeId: string, nodeType: NodeType, floor: number, position: number): void {\r\n        const node = this.createNode(nodeId, nodeType, floor, position);\r\n        \r\n        switch (nodeType) {\r\n            case NodeType.COMBAT:\r\n                this.setupCombatNode(node, floor);\r\n                break;\r\n            case NodeType.ELITE:\r\n                this.setupEliteNode(node, floor);\r\n                break;\r\n            case NodeType.EVENT:\r\n                this.setupEventNode(node, floor);\r\n                break;\r\n            case NodeType.SHOP:\r\n                this.setupShopNode(node, floor);\r\n                break;\r\n            case NodeType.TREASURE:\r\n                this.setupTreasureNode(node, floor);\r\n                break;\r\n            case NodeType.MYSTERY:\r\n                this.setupMysteryNode(node, floor);\r\n                break;\r\n        }\r\n    }\r\n    \r\n    private createNode(nodeId: string, nodeType: NodeType, floor: number, position: number): MapNode {\r\n        const node: MapNode = {\r\n            id: nodeId,\r\n            type: nodeType,\r\n            position: new Vec3(\r\n                (position - (this.getNodeCountForFloor(floor) - 1) / 2) * this.nodeSpacing,\r\n                floor * this.floorSpacing,\r\n                0\r\n            ),\r\n            connections: [],\r\n            isVisited: false,\r\n            isAvailable: floor === 0, // Only start nodes are initially available\r\n            isCurrentPath: false,\r\n            chapter: this._currentChapter,\r\n            floor: floor\r\n        };\r\n        \r\n        this._mapNodes.set(nodeId, node);\r\n        return node;\r\n    }\r\n    \r\n    private createCombatNode(nodeId: string, floor: number, position: number): void {\r\n        const node = this.createNode(nodeId, NodeType.COMBAT, floor, position);\r\n        this.setupCombatNode(node, floor);\r\n    }\r\n    \r\n    private setupCombatNode(node: MapNode, floor: number): void {\r\n        const baseDifficulty = 1 + (this._currentChapter - 1) * 0.5 + floor * 0.1;\r\n        \r\n        node.combatData = {\r\n            difficulty: baseDifficulty,\r\n            brickCount: Math.floor(20 + baseDifficulty * 5),\r\n            specialBrickRatio: Math.min(0.4, 0.2 + baseDifficulty * 0.05)\r\n        };\r\n    }\r\n    \r\n    private setupEliteNode(node: MapNode, floor: number): void {\r\n        const randomElite = this._availableEliteTypes[\r\n            Math.floor(Math.random() * this._availableEliteTypes.length)\r\n        ];\r\n        \r\n        const baseDifficulty = 1 + (this._currentChapter - 1) * 0.5 + floor * 0.1;\r\n        \r\n        node.eliteData = {\r\n            eliteType: randomElite,\r\n            difficulty: baseDifficulty * 1.4\r\n        };\r\n    }\r\n    \r\n    private setupEventNode(node: MapNode, floor: number): void {\r\n        const events = this.getAvailableEvents(this._chapterTheme, floor);\r\n        const randomEvent = events[Math.floor(Math.random() * events.length)];\r\n        \r\n        node.eventData = {\r\n            eventType: randomEvent.type,\r\n            choices: randomEvent.choices\r\n        };\r\n    }\r\n    \r\n    private setupShopNode(node: MapNode, floor: number): void {\r\n        node.shopData = {\r\n            items: this.generateShopItems(floor),\r\n            currency: 0 // Player's currency will be checked when entering\r\n        };\r\n    }\r\n    \r\n    private setupTreasureNode(node: MapNode, floor: number): void {\r\n        const treasureTypes = ['relic', 'currency', 'upgrade_material'];\r\n        const randomType = treasureTypes[Math.floor(Math.random() * treasureTypes.length)];\r\n        \r\n        node.treasureData = {\r\n            rewardType: randomType,\r\n            rewardValue: this.generateTreasureReward(randomType, floor)\r\n        };\r\n    }\r\n    \r\n    private setupMysteryNode(node: MapNode, floor: number): void {\r\n        // Mystery nodes have random effects that are revealed when entered\r\n        node.treasureData = {\r\n            rewardType: 'mystery',\r\n            rewardValue: { floor: floor, chapter: this._currentChapter }\r\n        };\r\n    }\r\n    \r\n    private generateConnections(): void {\r\n        const nodesByFloor = this.groupNodesByFloor();\r\n        \r\n        for (let floor = 0; floor < this.floorsPerChapter - 1; floor++) {\r\n            const currentFloorNodes = nodesByFloor.get(floor) || [];\r\n            const nextFloorNodes = nodesByFloor.get(floor + 1) || [];\r\n            \r\n            this.connectFloors(currentFloorNodes, nextFloorNodes, floor);\r\n        }\r\n    }\r\n    \r\n    private connectFloors(currentFloor: MapNode[], nextFloor: MapNode[], _floorIndex: number): void {\r\n        if (currentFloor.length === 0 || nextFloor.length === 0) return;\r\n        \r\n        // Each node in current floor connects to 1-3 nodes in next floor\r\n        for (const currentNode of currentFloor) {\r\n            const connectionCount = Math.min(\r\n                nextFloor.length,\r\n                Math.floor(Math.random() * 3) + 1\r\n            );\r\n            \r\n            // Choose random nodes to connect to, preferring nearby positions\r\n            const targetIndices = this.selectConnectionTargets(\r\n                currentFloor.indexOf(currentNode),\r\n                nextFloor.length,\r\n                connectionCount\r\n            );\r\n            \r\n            for (const targetIndex of targetIndices) {\r\n                const targetNode = nextFloor[targetIndex];\r\n                currentNode.connections.push(targetNode.id);\r\n            }\r\n        }\r\n        \r\n        // Ensure all next floor nodes are reachable\r\n        this.ensureNodesReachable(currentFloor, nextFloor);\r\n    }\r\n    \r\n    private selectConnectionTargets(sourceIndex: number, targetCount: number, connectionCount: number): number[] {\r\n        const targets: number[] = [];\r\n        const sourcePosition = sourceIndex / Math.max(1, targetCount - 1); // Normalize to 0-1\r\n        \r\n        // Prefer connections to nearby nodes\r\n        for (let i = 0; i < connectionCount; i++) {\r\n            let targetIndex: number;\r\n            \r\n            if (i === 0) {\r\n                // First connection: closest node\r\n                targetIndex = Math.round(sourcePosition * (targetCount - 1));\r\n            } else {\r\n                // Additional connections: random nearby nodes\r\n                const range = Math.min(2, Math.floor(targetCount / 2));\r\n                const centerIndex = Math.round(sourcePosition * (targetCount - 1));\r\n                const minIndex = Math.max(0, centerIndex - range);\r\n                const maxIndex = Math.min(targetCount - 1, centerIndex + range);\r\n                \r\n                do {\r\n                    targetIndex = Math.floor(Math.random() * (maxIndex - minIndex + 1)) + minIndex;\r\n                } while (targets.includes(targetIndex));\r\n            }\r\n            \r\n            targets.push(targetIndex);\r\n        }\r\n        \r\n        return targets;\r\n    }\r\n    \r\n    private ensureNodesReachable(currentFloor: MapNode[], nextFloor: MapNode[]): void {\r\n        const reachableNodes = new Set<string>();\r\n        \r\n        // Find all reachable nodes\r\n        for (const currentNode of currentFloor) {\r\n            for (const connectionId of currentNode.connections) {\r\n                reachableNodes.add(connectionId);\r\n            }\r\n        }\r\n        \r\n        // Connect unreachable nodes to random current floor nodes\r\n        for (const nextNode of nextFloor) {\r\n            if (!reachableNodes.has(nextNode.id)) {\r\n                const randomCurrentNode = currentFloor[Math.floor(Math.random() * currentFloor.length)];\r\n                randomCurrentNode.connections.push(nextNode.id);\r\n            }\r\n        }\r\n    }\r\n    \r\n    private createMapVisuals(): void {\r\n        this.clearMapVisuals();\r\n        \r\n        // Create node visuals\r\n        for (const [_nodeId, node] of this._mapNodes) {\r\n            this.createNodeVisual(node);\r\n        }\r\n        \r\n        // Create connection lines\r\n        this.createConnectionVisuals();\r\n    }\r\n    \r\n    private createNodeVisual(node: MapNode): void {\r\n        if (!this.mapNodePrefab) return;\r\n        \r\n        const nodeVisual = instantiate(this.mapNodePrefab);\r\n        const sprite = nodeVisual.getComponent(Sprite);\r\n        const label = nodeVisual.getComponentInChildren(Label);\r\n        const button = nodeVisual.getComponent(Button);\r\n        \r\n        if (sprite) {\r\n            sprite.color = this.getNodeColor(node.type);\r\n        }\r\n        \r\n        if (label) {\r\n            label.string = this.getNodeDisplayName(node.type);\r\n        }\r\n        \r\n        if (button) {\r\n            button.node.on(Button.EventType.CLICK, () => this.onNodeClicked(node.id), this);\r\n        }\r\n        \r\n        nodeVisual.setParent(this.node);\r\n        nodeVisual.setPosition(node.position);\r\n        \r\n        // Set availability visual state\r\n        this.updateNodeVisualState(nodeVisual, node);\r\n        \r\n        this._nodeVisuals.set(node.id, nodeVisual);\r\n    }\r\n    \r\n    private createConnectionVisuals(): void {\r\n        if (!this.connectionLinePrefab) return;\r\n        \r\n        for (const [_nodeId, node] of this._mapNodes) {\r\n            for (const connectionId of node.connections) {\r\n                const targetNode = this._mapNodes.get(connectionId);\r\n                if (!targetNode) continue;\r\n                \r\n                const line = instantiate(this.connectionLinePrefab);\r\n                line.setParent(this.node);\r\n                \r\n                // Position and scale line between nodes\r\n                const startPos = node.position;\r\n                const endPos = targetNode.position;\r\n                const midPos = Vec3.lerp(new Vec3(), startPos, endPos, 0.5);\r\n                const distance = Vec3.distance(startPos, endPos);\r\n                \r\n                line.setPosition(midPos);\r\n                \r\n                const transform = line.getComponent(UITransform);\r\n                if (transform) {\r\n                    transform.width = distance;\r\n                    \r\n                    // Rotate line to connect nodes\r\n                    const angle = Math.atan2(endPos.y - startPos.y, endPos.x - startPos.x);\r\n                    line.setRotationFromEuler(0, 0, angle * 180 / Math.PI);\r\n                }\r\n                \r\n                this._connectionLines.push(line);\r\n            }\r\n        }\r\n    }\r\n    \r\n    private getNodeColor(nodeType: NodeType): Color {\r\n        switch (nodeType) {\r\n            case NodeType.COMBAT: return new Color(150, 150, 150); // Gray\r\n            case NodeType.ELITE: return new Color(255, 165, 0);    // Orange\r\n            case NodeType.BOSS: return new Color(255, 0, 0);       // Red\r\n            case NodeType.EVENT: return new Color(0, 255, 255);    // Cyan\r\n            case NodeType.SHOP: return new Color(255, 255, 0);     // Yellow\r\n            case NodeType.TREASURE: return new Color(255, 215, 0); // Gold\r\n            case NodeType.CAMPFIRE: return new Color(255, 100, 0); // Orange-red\r\n            case NodeType.UPGRADE: return new Color(128, 0, 128);  // Purple\r\n            case NodeType.MYSTERY: return new Color(128, 128, 255); // Light blue\r\n            case NodeType.START: return new Color(0, 255, 0);      // Green\r\n            default: return new Color(255, 255, 255);              // White\r\n        }\r\n    }\r\n    \r\n    private getNodeDisplayName(nodeType: NodeType): string {\r\n        switch (nodeType) {\r\n            case NodeType.COMBAT: return \"战斗\";\r\n            case NodeType.ELITE: return \"精英\";\r\n            case NodeType.BOSS: return \"BOSS\";\r\n            case NodeType.EVENT: return \"事件\";\r\n            case NodeType.SHOP: return \"商店\";\r\n            case NodeType.TREASURE: return \"宝藏\";\r\n            case NodeType.CAMPFIRE: return \"篝火\";\r\n            case NodeType.UPGRADE: return \"升级\";\r\n            case NodeType.MYSTERY: return \"神秘\";\r\n            case NodeType.START: return \"开始\";\r\n            default: return \"未知\";\r\n        }\r\n    }\r\n    \r\n    public onNodeClicked(nodeId: string): void {\r\n        const node = this._mapNodes.get(nodeId);\r\n        if (!node || !node.isAvailable) {\r\n            console.log(`Node ${nodeId} is not available`);\r\n            return;\r\n        }\r\n        \r\n        console.log(`Player selected node: ${nodeId} (${node.type})`);\r\n        \r\n        // Mark current node as visited\r\n        node.isVisited = true;\r\n        node.isCurrentPath = true;\r\n        this._currentNodeId = nodeId;\r\n        \r\n        // Update node availability\r\n        this.updateNodeAvailability();\r\n        \r\n        // Trigger node action\r\n        this.executeNodeAction(node);\r\n        \r\n        // Update visuals\r\n        this.updateAllNodeVisuals();\r\n    }\r\n    \r\n    private executeNodeAction(node: MapNode): void {\r\n        switch (node.type) {\r\n            case NodeType.COMBAT:\r\n                this.startCombat(node);\r\n                break;\r\n            case NodeType.ELITE:\r\n                this.startEliteCombat(node);\r\n                break;\r\n            case NodeType.BOSS:\r\n                this.startBossCombat(node);\r\n                break;\r\n            case NodeType.EVENT:\r\n                this.triggerEvent(node);\r\n                break;\r\n            case NodeType.SHOP:\r\n                this.enterShop(node);\r\n                break;\r\n            case NodeType.TREASURE:\r\n                this.openTreasure(node);\r\n                break;\r\n            case NodeType.CAMPFIRE:\r\n                this.restAtCampfire(node);\r\n                break;\r\n            case NodeType.UPGRADE:\r\n                this.enterUpgradeStation(node);\r\n                break;\r\n            case NodeType.MYSTERY:\r\n                this.encounterMystery(node);\r\n                break;\r\n        }\r\n    }\r\n    \r\n    // Node action implementations\r\n    private startCombat(node: MapNode): void {\r\n        console.log(`Starting combat with difficulty ${node.combatData?.difficulty}`);\r\n        // Integrate with GameManager to start combat\r\n    }\r\n    \r\n    private startEliteCombat(node: MapNode): void {\r\n        console.log(`Starting elite combat: ${node.eliteData?.eliteType}`);\r\n        // Integrate with EliteAndHiddenBossManager\r\n    }\r\n    \r\n    private startBossCombat(node: MapNode): void {\r\n        console.log(`Starting boss combat: ${node.bossData?.bossType}`);\r\n        // Integrate with EnhancedBossController\r\n    }\r\n    \r\n    private triggerEvent(node: MapNode): void {\r\n        console.log(`Triggered event: ${node.eventData?.eventType}`);\r\n        // Show event UI with choices\r\n    }\r\n    \r\n    private enterShop(node: MapNode): void {\r\n        console.log(`Entered shop with ${node.shopData?.items.length} items`);\r\n        // Show shop UI\r\n    }\r\n    \r\n    private openTreasure(node: MapNode): void {\r\n        console.log(`Found treasure: ${node.treasureData?.rewardType}`);\r\n        // Award treasure and show UI\r\n    }\r\n    \r\n    private restAtCampfire(_node: MapNode): void {\r\n        console.log('Resting at campfire');\r\n        // Restore health, show rest options\r\n    }\r\n    \r\n    private enterUpgradeStation(_node: MapNode): void {\r\n        console.log('Entered upgrade station');\r\n        // Show upgrade options\r\n    }\r\n    \r\n    private encounterMystery(_node: MapNode): void {\r\n        console.log('Encountered mystery node');\r\n        // Random effect\r\n    }\r\n    \r\n    // Utility methods\r\n    private selectRandomNodeType(): NodeType {\r\n        const totalWeight = Array.from(this._nodeTypeDistribution.values()).reduce((sum, weight) => sum + weight, 0);\r\n        let random = Math.random() * totalWeight;\r\n        \r\n        for (const [nodeType, weight] of this._nodeTypeDistribution.entries()) {\r\n            random -= weight;\r\n            if (random <= 0) {\r\n                return nodeType;\r\n            }\r\n        }\r\n        \r\n        return NodeType.COMBAT; // Fallback\r\n    }\r\n    \r\n    private getNodeCountForFloor(floor: number): number {\r\n        if (floor === 0 || floor === this.floorsPerChapter - 1) {\r\n            return 1; // Start and boss floors have single nodes\r\n        } else if (floor === this.floorsPerChapter - 2) {\r\n            return this.nodesPerFloor - 1; // Pre-boss floor has slightly fewer options\r\n        } else {\r\n            return this.nodesPerFloor;\r\n        }\r\n    }\r\n    \r\n    private getChapterTheme(chapter: number): ChapterTheme {\r\n        switch (chapter) {\r\n            case 1: return ChapterTheme.FOREST;\r\n            case 2: return ChapterTheme.MOUNTAIN;\r\n            case 3: return ChapterTheme.ABYSS;\r\n            default: return ChapterTheme.FOREST;\r\n        }\r\n    }\r\n    \r\n    private groupNodesByFloor(): Map<number, MapNode[]> {\r\n        const floorGroups = new Map<number, MapNode[]>();\r\n        \r\n        for (const node of this._mapNodes.values()) {\r\n            if (!floorGroups.has(node.floor)) {\r\n                floorGroups.set(node.floor, []);\r\n            }\r\n            floorGroups.get(node.floor)!.push(node);\r\n        }\r\n        \r\n        return floorGroups;\r\n    }\r\n    \r\n    private getNodesByType(nodeType: NodeType): MapNode[] {\r\n        return Array.from(this._mapNodes.values()).filter(node => node.type === nodeType);\r\n    }\r\n    \r\n    private updateNodeAvailability(): void {\r\n        // Reset availability\r\n        for (const node of this._mapNodes.values()) {\r\n            node.isAvailable = false;\r\n        }\r\n        \r\n        // Make connected nodes available\r\n        const currentNode = this._mapNodes.get(this._currentNodeId);\r\n        if (currentNode) {\r\n            for (const connectionId of currentNode.connections) {\r\n                const connectedNode = this._mapNodes.get(connectionId);\r\n                if (connectedNode && !connectedNode.isVisited) {\r\n                    connectedNode.isAvailable = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    private updateAllNodeVisuals(): void {\r\n        for (const [nodeId, node] of this._mapNodes) {\r\n            const visual = this._nodeVisuals.get(nodeId);\r\n            if (visual) {\r\n                this.updateNodeVisualState(visual, node);\r\n            }\r\n        }\r\n    }\r\n    \r\n    private updateNodeVisualState(visual: Node, node: MapNode): void {\r\n        const sprite = visual.getComponent(Sprite);\r\n        if (!sprite) return;\r\n        \r\n        if (node.isVisited) {\r\n            sprite.color = new Color(100, 100, 100, 180); // Dark and semi-transparent\r\n        } else if (node.isAvailable) {\r\n            sprite.color = this.getNodeColor(node.type);\r\n        } else {\r\n            sprite.color = new Color(80, 80, 80, 100); // Very dark and transparent\r\n        }\r\n        \r\n        // Highlight current node\r\n        if (node.id === this._currentNodeId) {\r\n            sprite.color = Color.WHITE;\r\n        }\r\n    }\r\n    \r\n    private clearCurrentMap(): void {\r\n        this._mapNodes.clear();\r\n        this.clearMapVisuals();\r\n    }\r\n    \r\n    private clearMapVisuals(): void {\r\n        // Clear node visuals\r\n        for (const visual of this._nodeVisuals.values()) {\r\n            visual.destroy();\r\n        }\r\n        this._nodeVisuals.clear();\r\n        \r\n        // Clear connection lines\r\n        for (const line of this._connectionLines) {\r\n            line.destroy();\r\n        }\r\n        this._connectionLines = [];\r\n    }\r\n    \r\n    // Event and shop data generation\r\n    private getAvailableEvents(_theme: ChapterTheme, _floor: number): any[] {\r\n        // This would be expanded with actual event data\r\n        return [\r\n            {\r\n                type: 'mysterious_shrine',\r\n                choices: [\r\n                    {\r\n                        id: 'pray',\r\n                        text: '祈祷获得祝福',\r\n                        consequences: [{ type: 'relic', value: 'random', description: '获得随机遗物' }]\r\n                    },\r\n                    {\r\n                        id: 'ignore',\r\n                        text: '无视神龛',\r\n                        consequences: [{ type: 'currency', value: 20, description: '获得20金币' }]\r\n                    }\r\n                ]\r\n            }\r\n        ];\r\n    }\r\n    \r\n    private generateShopItems(_floor: number): ShopItem[] {\r\n        // Generate shop items based on floor and chapter\r\n        return [\r\n            {\r\n                id: 'health_potion',\r\n                name: '生命药水',\r\n                description: '恢复50点生命值',\r\n                type: 'consumable',\r\n                cost: 75,\r\n                data: { healing: 50 }\r\n            },\r\n            {\r\n                id: 'damage_relic',\r\n                name: '力量护符',\r\n                description: '永久增加10%伤害',\r\n                type: 'relic',\r\n                cost: 150,\r\n                data: { damageBonus: 0.1 }\r\n            }\r\n        ];\r\n    }\r\n    \r\n    private generateTreasureReward(rewardType: string, floor: number): any {\r\n        switch (rewardType) {\r\n            case 'relic':\r\n                return { relicType: 'random', tier: 'common' };\r\n            case 'currency':\r\n                return { amount: 50 + floor * 10 };\r\n            case 'upgrade_material':\r\n                return { type: 'enhancement_stone', quantity: 2 };\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n    \r\n    private _saveMapProgress(): void {\r\n        // Save current map state\r\n        console.log('Map progress saved');\r\n    }\r\n    \r\n    private loadMapProgress(): void {\r\n        // Load saved map state\r\n        console.log('Map progress loaded');\r\n    }\r\n    \r\n    // Public accessors\r\n    public getCurrentNode(): MapNode | undefined {\r\n        return this._mapNodes.get(this._currentNodeId);\r\n    }\r\n    \r\n    public getCurrentChapter(): number {\r\n        return this._currentChapter;\r\n    }\r\n    \r\n    public getCurrentFloor(): number {\r\n        const currentNode = this.getCurrentNode();\r\n        return currentNode ? currentNode.floor : 0;\r\n    }\r\n    \r\n    public isChapterComplete(): boolean {\r\n        const currentNode = this.getCurrentNode();\r\n        return currentNode?.type === NodeType.BOSS && currentNode.isVisited;\r\n    }\r\n    \r\n    public getNextChapterAvailable(): boolean {\r\n        return this.isChapterComplete() && this._currentChapter < 3;\r\n    }\r\n    \r\n    private calculateAvailableNodes(): void {\r\n        // Calculate which nodes are available based on current progress\r\n        // Initially only starting nodes are available\r\n        for (const [_nodeId, node] of this._mapNodes) {\r\n            if (node.type === NodeType.START) {\r\n                node.isAvailable = true;\r\n            } else {\r\n                node.isAvailable = false;\r\n            }\r\n        }\r\n        \r\n        // Update available nodes based on completed nodes\r\n        this.updateAvailableNodes();\r\n    }\r\n    \r\n    private updateAvailableNodes(): void {\r\n        // Unlock nodes that are connected to completed nodes\r\n        for (const completedNode of this._completedNodes) {\r\n            for (const connectionId of completedNode.connections) {\r\n                const connectedNode = this.getNodeById(connectionId);\r\n                if (connectedNode) {\r\n                    connectedNode.isAvailable = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    private getNodeById(nodeId: string): MapNode | undefined {\r\n        return this._mapNodes.get(nodeId);\r\n    }\r\n\r\n    // 添加测试需要的方法  \r\n    public getCurrentNodeType(): NodeType {\r\n        const currentNode = this.getNodeById(this._currentNodeId);\r\n        return currentNode ? currentNode.type : NodeType.START;\r\n    }\r\n\r\n    public getMapSize(): number {\r\n        return this._mapNodes.size;\r\n    }\r\n\r\n    public getAvailableNodes(): MapNode[] {\r\n        return Array.from(this._mapNodes.values()).filter(node => node.isAvailable);\r\n    }\r\n\r\n    public getCompletedNodesCount(): number {\r\n        return this._completedNodes.length;\r\n    }\r\n\r\n    public canNavigateToNode(nodeId: string): boolean {\r\n        const targetNode = this.getNodeById(nodeId);\r\n        if (!targetNode) return false;\r\n        return targetNode.isAvailable && !targetNode.isVisited;\r\n    }\r\n\r\n    public getNodeConnections(nodeId: string): string[] {\r\n        const node = this.getNodeById(nodeId);\r\n        return node ? node.connections : [];\r\n    }\r\n\r\n    public getShortestPath(fromNodeId: string, toNodeId: string): string[] {\r\n        // 简单的BFS路径查找实现\r\n        const visited = new Set<string>();\r\n        const queue: { nodeId: string, path: string[] }[] = [];\r\n        \r\n        queue.push({ nodeId: fromNodeId, path: [fromNodeId] });\r\n        visited.add(fromNodeId);\r\n        \r\n        while (queue.length > 0) {\r\n            const { nodeId, path } = queue.shift()!;\r\n            \r\n            if (nodeId === toNodeId) {\r\n                return path;\r\n            }\r\n            \r\n            const node = this.getNodeById(nodeId);\r\n            if (node) {\r\n                for (const connectionId of node.connections) {\r\n                    if (!visited.has(connectionId)) {\r\n                        visited.add(connectionId);\r\n                        queue.push({ \r\n                            nodeId: connectionId, \r\n                            path: [...path, connectionId] \r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return []; // 无路径\r\n    }\r\n\r\n    public getNodeData(nodeId: string): MapNode | null {\r\n        return this.getNodeById(nodeId) || null;\r\n    }\r\n\r\n    public getAllNodes(): MapNode[] {\r\n        return Array.from(this._mapNodes.values());\r\n    }\r\n\r\n    public resetMap(): void {\r\n        this._mapNodes.clear();\r\n        this._completedNodes = [];\r\n        this._currentFloor = 0;\r\n        this._currentNodeId = '';\r\n        this.clearMapVisuals();\r\n    }\r\n}"]}