# æµ‹è¯•æ–¹æ³•ç¤ºä¾‹ä¸æœ€ä½³å®è·µ

## ğŸ¯ æµ‹è¯•æ–¹æ³•åˆ†ç±»

### 1. åŠŸèƒ½æµ‹è¯• (Functional Testing)

éªŒè¯ç³»ç»ŸåŠŸèƒ½æ˜¯å¦æŒ‰é¢„æœŸå·¥ä½œã€‚

#### ç¤ºä¾‹ï¼šæŒ¡æ¿ç§»åŠ¨åŠŸèƒ½æµ‹è¯•
```typescript
describe('æŒ¡æ¿ç§»åŠ¨åŠŸèƒ½', () => {
    test('åº”è¯¥èƒ½å¤Ÿå‘å·¦ç§»åŠ¨æŒ‡å®šè·ç¦»', () => {
        // Arrange (å‡†å¤‡)
        const initialPosition = paddleNode.getPosition();
        const moveTime = 0.1;
        const expectedSpeed = 300;
        
        // Act (æ‰§è¡Œ)
        paddleController.moveLeft(moveTime);
        
        // Assert (éªŒè¯)
        const newPosition = paddleNode.getPosition();
        const actualDistance = initialPosition.x - newPosition.x;
        const expectedDistance = expectedSpeed * moveTime;
        
        expect(actualDistance).toBeCloseTo(expectedDistance, 1);
        expect(newPosition.y).toBe(initialPosition.y); // Yåæ ‡ä¸å˜
    });
});
```

#### æœ€ä½³å®è·µ:
- âœ… ä½¿ç”¨AAAæ¨¡å¼ç»„ç»‡æµ‹è¯•
- âœ… æµ‹è¯•ä¸€ä¸ªå…·ä½“åŠŸèƒ½ç‚¹
- âœ… æä¾›æ¸…æ™°çš„æµ‹è¯•æè¿°
- âœ… éªŒè¯æ‰€æœ‰ç›¸å…³çŠ¶æ€å˜åŒ–

### 2. è¾¹ç•Œæµ‹è¯• (Boundary Testing)

æµ‹è¯•ç³»ç»Ÿåœ¨è¾¹ç•Œæ¡ä»¶ä¸‹çš„è¡Œä¸ºã€‚

#### ç¤ºä¾‹ï¼šæŒ¡æ¿è¾¹ç•Œé™åˆ¶æµ‹è¯•
```typescript
describe('æŒ¡æ¿è¾¹ç•Œé™åˆ¶', () => {
    test('ä¸åº”è¯¥ç§»åŠ¨è¶…å‡ºå·¦è¾¹ç•Œ', () => {
        // Arrange
        const screenWidth = 960;
        const paddleWidth = 100;
        const boundaryMargin = 50;
        const leftBoundary = -(screenWidth / 2) + (paddleWidth / 2) + boundaryMargin;
        
        // å°†æŒ¡æ¿ç§»åŠ¨åˆ°è¾¹ç•Œå¤–
        paddleNode.setPosition(leftBoundary - 100, -250, 0);
        
        // Act
        paddleController.moveLeft(1.0); // é•¿æ—¶é—´ç§»åŠ¨
        
        // Assert
        const finalPosition = paddleNode.getPosition();
        expect(finalPosition.x).toBeGreaterThanOrEqual(leftBoundary);
    });
    
    test('åº”è¯¥æ­£ç¡®å¤„ç†æç«¯è¾“å…¥å€¼', () => {
        const initialPosition = paddleNode.getPosition().clone();
        
        // æµ‹è¯•è´Ÿæ•°æ—¶é—´
        paddleController.moveLeft(-0.1);
        expect(paddleNode.getPosition().equals(initialPosition)).toBe(true);
        
        // æµ‹è¯•é›¶æ—¶é—´
        paddleController.moveLeft(0);
        expect(paddleNode.getPosition().equals(initialPosition)).toBe(true);
        
        // æµ‹è¯•NaN
        paddleController.moveLeft(NaN);
        expect(paddleNode.getPosition().equals(initialPosition)).toBe(true);
        
        // æµ‹è¯•Infinity
        paddleController.moveLeft(Infinity);
        expect(paddleNode.getPosition().x).toBeFinite();
    });
});
```

### 3. çŠ¶æ€æµ‹è¯• (State Testing)

éªŒè¯å¯¹è±¡çŠ¶æ€è½¬æ¢çš„æ­£ç¡®æ€§ã€‚

#### ç¤ºä¾‹ï¼šå¼¹çƒçŠ¶æ€ç®¡ç†æµ‹è¯•
```typescript
describe('å¼¹çƒçŠ¶æ€ç®¡ç†', () => {
    test('åº”è¯¥æ­£ç¡®ç®¡ç†è¿åŠ¨çŠ¶æ€', () => {
        // åˆå§‹çŠ¶æ€ï¼šæœªç§»åŠ¨
        expect(ball.isMoving).toBe(false);
        
        // å‘å°„åï¼šæ­£åœ¨ç§»åŠ¨
        ball.launch(new Vec3(1, 1, 0).normalize());
        expect(ball.isMoving).toBe(true);
        
        // é‡ç½®åï¼šåœæ­¢ç§»åŠ¨
        ball.resetBall();
        expect(ball.isMoving).toBe(false);
    });
    
    test('åº”è¯¥æ­£ç¡®ç®¡ç†ç‰¹æ•ˆçŠ¶æ€', () => {
        // åº”ç”¨ç«ç„°ç‰¹æ•ˆ
        ball.applyFireEffect(5.0);
        expect(ball.hasFireEffect()).toBe(true);
        expect(ball.getFireEffectDuration()).toBe(5.0);
        
        // æ—¶é—´æµé€
        ball.update(2.0);
        expect(ball.getFireEffectDuration()).toBe(3.0);
        
        // ç‰¹æ•ˆç»“æŸ
        ball.update(3.1);
        expect(ball.hasFireEffect()).toBe(false);
    });
});
```

### 4. äº¤äº’æµ‹è¯• (Interaction Testing)

æµ‹è¯•ç»„ä»¶é—´çš„äº¤äº’è¡Œä¸ºã€‚

#### ç¤ºä¾‹ï¼šç¢°æ’æ£€æµ‹äº¤äº’æµ‹è¯•
```typescript
describe('ç¢°æ’æ£€æµ‹äº¤äº’', () => {
    test('å¼¹çƒä¸æŒ¡æ¿ç¢°æ’åº”è¯¥æ”¹å˜å¼¹çƒæ–¹å‘', () => {
        // Arrange
        ball.start();
        const mockPaddle = new Node('MockPaddle');
        mockPaddle.addComponent('PaddleController');
        mockPaddle.setPosition(0, -200, 0);
        
        ballNode.setPosition(50, -180, 0); // çƒåœ¨æŒ¡æ¿å³ä¾§
        const originalVelocity = new Vec3(100, -200, 0);
        ball.setVelocity(originalVelocity);
        
        // Act
        const mockContact = {
            otherCollider: { node: mockPaddle }
        };
        ball.onBeginContact(null, mockContact, null);
        
        // Assert
        const newVelocity = ball.getVelocity();
        expect(newVelocity.y).toBeGreaterThan(0); // å‘ä¸Šåå¼¹
        expect(newVelocity.x).toBeGreaterThan(originalVelocity.x); // è§’åº¦åè½¬
    });
    
    test('é—ç‰©æ•ˆæœåº”è¯¥æ­£ç¡®å½±å“å¼¹çƒè¡Œä¸º', () => {
        // Arrange
        const relicManager = RelicManager.getInstance();
        relicManager.grantRelic(RelicType.FIRE_BALLS);
        
        const mockBall = new Node('MockBall');
        
        // Act
        relicManager.onBallLaunched(mockBall);
        
        // Assert
        const fireEffectApplied = mockBall.getComponent('Ball')?.hasFireEffect();
        expect(fireEffectApplied).toBe(true);
    });
});
```

### 5. æ€§èƒ½æµ‹è¯• (Performance Testing)

éªŒè¯ç³»ç»Ÿåœ¨è´Ÿè½½ä¸‹çš„æ€§èƒ½è¡¨ç°ã€‚

#### ç¤ºä¾‹ï¼šæ‰¹é‡æ“ä½œæ€§èƒ½æµ‹è¯•
```typescript
describe('æ€§èƒ½æµ‹è¯•', () => {
    test('æ‰¹é‡æ›´æ–°åº”è¯¥åœ¨åˆç†æ—¶é—´å†…å®Œæˆ', () => {
        const startTime = performance.now();
        const iterations = 1000;
        
        // æ‰§è¡Œå¤§é‡æ›´æ–°æ“ä½œ
        for (let i = 0; i < iterations; i++) {
            paddleController.update(0.016); // æ¨¡æ‹Ÿ60FPS
        }
        
        const endTime = performance.now();
        const duration = endTime - startTime;
        const avgTimePerUpdate = duration / iterations;
        
        expect(duration).toBeLessThan(100); // æ€»æ—¶é—´ä¸è¶…è¿‡100ms
        expect(avgTimePerUpdate).toBeLessThan(0.1); // æ¯æ¬¡æ›´æ–°ä¸è¶…è¿‡0.1ms
    });
    
    test('å†…å­˜ä½¿ç”¨åº”è¯¥ä¿æŒç¨³å®š', () => {
        const initialMemory = process.memoryUsage().heapUsed;
        
        // æ‰§è¡Œå¯èƒ½é€ æˆå†…å­˜æ³„æ¼çš„æ“ä½œ
        for (let i = 0; i < 100; i++) {
            const tempBall = new Node(`TempBall${i}`);
            tempBall.addComponent('Ball');
            // æ¨¡æ‹Ÿåˆ›å»ºå’Œé”€æ¯
            tempBall.destroy();
        }
        
        // å¼ºåˆ¶åƒåœ¾å›æ”¶ (ä»…åœ¨æµ‹è¯•ç¯å¢ƒ)
        if (global.gc) global.gc();
        
        const finalMemory = process.memoryUsage().heapUsed;
        const memoryIncrease = finalMemory - initialMemory;
        
        expect(memoryIncrease).toBeLessThan(1024 * 1024); // å¢é•¿ä¸è¶…è¿‡1MB
    });
});
```

### 6. é”™è¯¯å¤„ç†æµ‹è¯• (Error Handling Testing)

éªŒè¯ç³»ç»Ÿå¯¹å¼‚å¸¸æƒ…å†µçš„å¤„ç†èƒ½åŠ›ã€‚

#### ç¤ºä¾‹ï¼šå¼‚å¸¸è¾“å…¥å¤„ç†æµ‹è¯•
```typescript
describe('é”™è¯¯å¤„ç†', () => {
    test('åº”è¯¥ä¼˜é›…å¤„ç†ç©ºæŒ‡é’ˆå¼‚å¸¸', () => {
        expect(() => {
            ball.onBeginContact(null, null, null);
        }).not.toThrow();
        
        expect(() => {
            ball.onBeginContact(null, { otherCollider: null }, null);
        }).not.toThrow();
        
        expect(() => {
            ball.onBeginContact(null, { otherCollider: { node: null } }, null);
        }).not.toThrow();
    });
    
    test('åº”è¯¥å¤„ç†æ— æ•ˆçš„ä¿å­˜æ•°æ®', () => {
        const saveManager = SaveManager.getInstance();
        
        // æµ‹è¯•å„ç§æ— æ•ˆè¾“å…¥
        const invalidInputs = [
            null,
            undefined,
            {},
            { invalidField: 'value' },
            { playerProgress: null },
            { playerProgress: { totalScore: 'invalid' } }
        ];
        
        invalidInputs.forEach(input => {
            expect(() => {
                saveManager.loadFromSaveData(input);
            }).not.toThrow();
        });
        
        // éªŒè¯åŠ è½½å¤±è´¥åç³»ç»Ÿä»å¯ç”¨
        expect(saveManager.getPlayerProgress()).toBeDefined();
    });
});
```

### 7. é›†æˆæµ‹è¯• (Integration Testing)

æµ‹è¯•å¤šä¸ªç»„ä»¶ååŒå·¥ä½œçš„åœºæ™¯ã€‚

#### ç¤ºä¾‹ï¼šå®Œæ•´æ¸¸æˆæµç¨‹æµ‹è¯•
```typescript
describe('æ¸¸æˆæµç¨‹é›†æˆæµ‹è¯•', () => {
    test('å®Œæ•´çš„ç –å—ç ´åæµç¨‹', () => {
        // Arrange - è®¾ç½®å®Œæ•´çš„æ¸¸æˆåœºæ™¯
        const gameManager = GameManager.getInstance();
        const relicManager = RelicManager.getInstance();
        const effectSystem = AdvancedEffectSystem.getInstance();
        
        gameManager.initializeGame();
        relicManager.grantRelic(RelicType.EXPLOSIVE_BRICKS);
        
        // Act - æ¨¡æ‹Ÿå¼¹çƒå‡»ä¸­ç –å—
        const mockBrick = new Node('TestBrick');
        mockBrick.setPosition(100, 100, 0);
        mockBrick.addComponent('Brick');
        
        const initialScore = gameManager.getScore();
        
        // è§¦å‘ç –å—è¢«ç ´åäº‹ä»¶
        gameManager.onBrickDestroyed(10, mockBrick.getPosition(), true);
        relicManager.onBrickDestroyed(mockBrick);
        
        // Assert - éªŒè¯æ‰€æœ‰ç›¸å…³ç³»ç»Ÿå“åº”
        expect(gameManager.getScore()).toBe(initialScore + 10);
        expect(mockBrick.isValid).toBe(false); // ç –å—è¢«é”€æ¯
        
        // éªŒè¯çˆ†ç‚¸æ•ˆæœè¢«è§¦å‘
        const activeEffects = effectSystem.getActiveEffects();
        expect(activeEffects.some(effect => 
            effect.type === 'brick_explosion'
        )).toBe(true);
    });
});
```

## ğŸ› ï¸ Mock ç­–ç•¥è¯¦è§£

### 1. ç»„ä»¶ Mock
```typescript
// åˆ›å»ºè½»é‡çº§çš„ç»„ä»¶Mock
function createMockNode(name: string = 'MockNode') {
    return {
        name,
        _position: new Vec3(0, 0, 0),
        _components: new Map(),
        
        getPosition(): Vec3 { return this._position.clone(); },
        setPosition(pos: Vec3): void { this._position = pos.clone(); },
        
        addComponent<T>(type: string): T {
            const component = createMockComponent(type);
            this._components.set(type, component);
            return component as T;
        },
        
        getComponent<T>(type: string): T | null {
            return this._components.get(type) as T || null;
        },
        
        destroy(): void { this._destroyed = true; },
        get isValid(): boolean { return !this._destroyed; }
    };
}
```

### 2. ç‰©ç†ç³»ç»Ÿ Mock
```typescript
function createMockRigidBody() {
    return {
        linearVelocity: new Vec3(0, 0, 0),
        body: {
            SetLinearVelocity: jest.fn(),
            GetLinearVelocity: jest.fn().mockReturnValue({ x: 0, y: 0 }),
            SetTransform: jest.fn(),
            GetTransform: jest.fn()
        },
        
        // æ¨¡æ‹Ÿç‰©ç†æ›´æ–°
        simulatePhysicsStep(deltaTime: number): void {
            // ç®€å•çš„ä½ç½®æ›´æ–°æ¨¡æ‹Ÿ
            this.linearVelocity.multiplyScalar(0.99); // æ¨¡æ‹Ÿé˜»å°¼
        }
    };
}
```

### 3. äº‹ä»¶ç³»ç»Ÿ Mock
```typescript
function createMockEventSystem() {
    const listeners = new Map<string, Function[]>();
    
    return {
        on(event: string, callback: Function): void {
            if (!listeners.has(event)) {
                listeners.set(event, []);
            }
            listeners.get(event)!.push(callback);
        },
        
        emit(event: string, ...args: any[]): void {
            const callbacks = listeners.get(event) || [];
            callbacks.forEach(callback => callback(...args));
        },
        
        off(event: string, callback: Function): void {
            const callbacks = listeners.get(event) || [];
            const index = callbacks.indexOf(callback);
            if (index !== -1) {
                callbacks.splice(index, 1);
            }
        }
    };
}
```

## ğŸ“Š æµ‹è¯•æ•°æ®ç”Ÿæˆ

### 1. éšæœºæµ‹è¯•æ•°æ®
```typescript
class TestDataGenerator {
    static randomPosition(bounds?: {min: Vec3, max: Vec3}): Vec3 {
        const min = bounds?.min || new Vec3(-500, -300, 0);
        const max = bounds?.max || new Vec3(500, 300, 0);
        
        return new Vec3(
            Math.random() * (max.x - min.x) + min.x,
            Math.random() * (max.y - min.y) + min.y,
            0
        );
    }
    
    static randomVelocity(maxSpeed: number = 500): Vec3 {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * maxSpeed;
        
        return new Vec3(
            Math.cos(angle) * speed,
            Math.sin(angle) * speed,
            0
        );
    }
    
    static randomPlayerProgress(): PlayerProgress {
        return {
            currentChapter: Math.floor(Math.random() * 3) + 1,
            currentFloor: Math.floor(Math.random() * 15) + 1,
            totalScore: Math.floor(Math.random() * 100000),
            // ... å…¶ä»–éšæœºå­—æ®µ
        };
    }
}

// ä½¿ç”¨ç¤ºä¾‹
test('åº”è¯¥å¤„ç†éšæœºç©å®¶æ•°æ®', () => {
    const randomProgress = TestDataGenerator.randomPlayerProgress();
    const saveManager = SaveManager.getInstance();
    
    expect(() => {
        saveManager.setPlayerProgress(randomProgress);
    }).not.toThrow();
});
```

### 2. è¾¹ç•Œå€¼æµ‹è¯•æ•°æ®
```typescript
class BoundaryTestData {
    static getPositionBoundaries() {
        return [
            new Vec3(0, 0, 0),                    // åŸç‚¹
            new Vec3(-480, -320, 0),              // å·¦ä¸‹è§’
            new Vec3(480, 320, 0),                // å³ä¸Šè§’
            new Vec3(Number.MAX_VALUE, 0, 0),     // æå¤§å€¼
            new Vec3(-Number.MAX_VALUE, 0, 0),    // æå°å€¼
            new Vec3(NaN, NaN, 0),                // NaNå€¼
            new Vec3(Infinity, -Infinity, 0)      // æ— ç©·å€¼
        ];
    }
    
    static getScoreBoundaries() {
        return [
            0, 1, -1,
            Number.MAX_SAFE_INTEGER,
            Number.MIN_SAFE_INTEGER,
            Number.MAX_VALUE,
            -Number.MAX_VALUE,
            NaN, Infinity, -Infinity
        ];
    }
}
```

## ğŸ¯ æ–­è¨€æœ€ä½³å®è·µ

### 1. ç²¾ç¡®æ–­è¨€
```typescript
// âŒ æ¨¡ç³Šæ–­è¨€
expect(result).toBeTruthy();

// âœ… ç²¾ç¡®æ–­è¨€
expect(result.success).toBe(true);
expect(result.data).toBeDefined();
expect(result.errorCode).toBe(0);
```

### 2. æµ®ç‚¹æ•°æ¯”è¾ƒ
```typescript
// âŒ ç›´æ¥æ¯”è¾ƒæµ®ç‚¹æ•°
expect(actualDistance).toBe(expectedDistance);

// âœ… ä½¿ç”¨ç²¾åº¦å®¹é”™
expect(actualDistance).toBeCloseTo(expectedDistance, 2);
```

### 3. å¼‚æ­¥æ–­è¨€
```typescript
// âŒ ä¸ç­‰å¾…å¼‚æ­¥æ“ä½œ
test('å¼‚æ­¥åŠ è½½', () => {
    saveManager.loadAsync();
    expect(saveManager.isLoaded()).toBe(true);
});

// âœ… æ­£ç¡®å¤„ç†å¼‚æ­¥
test('å¼‚æ­¥åŠ è½½', async () => {
    await saveManager.loadAsync();
    expect(saveManager.isLoaded()).toBe(true);
});
```

## ğŸ”§ è°ƒè¯•æŠ€å·§

### 1. æµ‹è¯•éš”ç¦»
```typescript
describe('éš”ç¦»æµ‹è¯•', () => {
    let originalConsoleError: typeof console.error;
    
    beforeAll(() => {
        // é™é»˜é”™è¯¯æ—¥å¿—
        originalConsoleError = console.error;
        console.error = jest.fn();
    });
    
    afterAll(() => {
        // æ¢å¤åŸå§‹æ—¥å¿—
        console.error = originalConsoleError;
    });
    
    beforeEach(() => {
        // æ¯ä¸ªæµ‹è¯•å‰é‡ç½®Mock
        jest.clearAllMocks();
    });
});
```

### 2. è°ƒè¯•ä¿¡æ¯è¾“å‡º
```typescript
test('å¤æ‚é€»è¾‘è°ƒè¯•', () => {
    const debugInfo = {
        initialState: paddle.getState(),
        inputEvent: mockEvent,
        expectedResult: expectedState
    };
    
    try {
        paddle.handleInput(mockEvent);
        const actualResult = paddle.getState();
        
        expect(actualResult).toEqual(expectedResult);
    } catch (error) {
        console.log('è°ƒè¯•ä¿¡æ¯:', debugInfo);
        console.log('å®é™…ç»“æœ:', paddle.getState());
        throw error;
    }
});
```

### 3. æ¡ä»¶æµ‹è¯•
```typescript
// æ ¹æ®ç¯å¢ƒæ¡ä»¶è·³è¿‡æµ‹è¯•
const skipOnCI = process.env.CI ? test.skip : test;

skipOnCI('æœ¬åœ°ç¯å¢ƒæ€§èƒ½æµ‹è¯•', () => {
    // åªåœ¨æœ¬åœ°è¿è¡Œçš„æ€§èƒ½æµ‹è¯•
});
```

---

**ğŸ® é€šè¿‡è¿™äº›æµ‹è¯•æ–¹æ³•å’Œæœ€ä½³å®è·µï¼Œæˆ‘ä»¬ç¡®ä¿ Cat-Conquest æ¸¸æˆç³»ç»Ÿçš„é«˜è´¨é‡å’Œç¨³å®šæ€§ï¼**